<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>诗词自赏</title>
    <link href="/2025/04/06/shici/"/>
    <url>/2025/04/06/shici/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虞美人"><a href="#虞美人" class="headerlink" title="虞美人"></a>虞美人</h1><p>李煜</p><p>春花秋月何时了，往事知多少？小楼昨夜又东风，故国不堪回首月明中。</p><p>雕栏玉砌应犹在，只是朱颜改。问君能有几多愁？恰似一江春水向东流。</p>]]></content>
    
    
    <categories>
      
      <category>诗词</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件体系结构</title>
    <link href="/2025/03/30/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2025/03/30/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2025/03/30/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2025-03-30%20155451.png" alt="软件体系结构"></p><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a><strong>复习</strong></h1><p>1、Software architecture’s definition and concept.</p><p><strong>对应章节</strong>：第1章 <strong>What Is Software Architecture?</strong></p><p>2、The definition, concepts, and types of Module Structure, Allocation Structure, and C&amp;C Structure.</p><p><strong>对应章节</strong>：</p><ul><li><p>第1章</p><p>Architectural Structures and Views</p></li><li><p>第18章</p><p>Documenting Software Architectures</p></li></ul><p>3、Relationships between Pattern and Tactics.</p><p><strong>对应章节</strong>：第13章 <strong>Architectural Tactics and Patterns</strong></p><p>4、The types, concepts, and tactics of QAs（质量属性）. For example:</p><ul><li>Availability and related tactics (e.g., how to detect faults?)</li><li>Performance and related tactics</li><li>Security and related tactics</li><li>Interoperability and related tactics (e.g., how Service Discovery works)</li><li>Quality attribute scenarios</li></ul><p><strong>对应章节</strong>：</p><ul><li><p>第4章</p><p>Understanding Quality Attributes</p><ul><li>总体介绍质量属性（QAs）的概念、分类及实现方式</li></ul></li><li><p>第5章至第11章</p><ul><li><p>第5章：Availability</p><ul><li><p>讨论可用性及相关战术第8章：Performance</p></li><li><p>涉及性能战术</p></li></ul></li><li><p>第9章：Security</p><ul><li>涉及安全相关的战术</li></ul></li><li><p>第6章：Interoperability</p><ul><li>涉及互操作性的战术（如服务发现的工作原理）</li></ul></li><li><p>第12章：Quality Attribute Scenarios</p><ul><li>描述质量属性场景的建模与应用</li></ul></li></ul></li></ul><p>5、Architectural Pattern. For example:</p><ul><li>P2P’s definition, basic concepts, related QAs (e.g., availability and performance), weaknesses (how to improve?), strengths, and trade-offs</li><li>MapReduce’s</li><li>Pub&#x2F;Sub’s</li><li>MVC’s</li></ul><p><strong>对应章节</strong>：第13章 <strong>Architectural Tactics and Patterns</strong></p><ul><li>包括P2P、MapReduce、Pub&#x2F;Sub、MVC等模式的定义、基本概念、相关质量属性（QAs），及其优缺点和权衡分析(软件构架实践英文第三版)。</li></ul><p>6、Definition, concepts, and steps (procedure) of ATAM, ASRs, ADD, and Utility Tree.</p><p><strong>对应章节</strong>：</p><ul><li>ATAM (Architecture Tradeoff Analysis Method)：第21章 Architecture Evaluation<ul><li>详细说明ATAM的定义、步骤及用途</li></ul></li><li>ASRs (Architecturally Significant Requirements)：第16章 Architecture and Requirements<ul><li>描述了如何从需求文档中提取和捕获ASRs</li></ul></li><li>ADD (Attribute-Driven Design)：第17章 Designing an Architecture<ul><li>包括ADD方法的定义及分步过程</li></ul></li><li>Utility Tree：第16章 Architecture and Requirements<ul><li>提供了Utility Tree的定义、概念和具体应用</li></ul></li></ul><p>1、The definition, concepts, and types of Module Structure, Allocation Structure, and C&amp;C Structure. For example:</p><ul><li>Seven categories of design decisions?</li><li>Its role in project risk reduction? (how to reduce risks?)</li></ul><p><strong>对应章节</strong>：</p><ul><li>第1章：Architectural Structures and Views<ul><li>描述了模块结构（Module Structure）、分配结构（Allocation Structure）和组件与连接器结构（C&amp;C Structure）的定义、类型及其特点</li></ul></li><li>第4章：Understanding Quality Attributes<ul><li>涉及架构决策对风险和质量属性的影响，例如“如何通过架构设计减少项目风险”</li></ul></li></ul><p>2、The types, concepts, and tactics of QAs. For example:</p><ul><li>Availability and related tactics (e.g., how to detect faults?)</li><li>Performance and related tactics</li></ul><p><strong>对应章节</strong>：</p><ul><li>第4章：Understanding Quality Attributes<ul><li>总体介绍质量属性（QAs）的定义、分类以及实现方法</li></ul></li><li>第5章：Availability<ul><li>专注于可用性及其相关战术，例如故障检测的技术</li></ul></li><li>第8章：Performance<ul><li>讨论性能相关战术和设计</li></ul></li></ul><p>3、Architectural Pattern. For example:</p><ul><li>P2P’s definition, basic concepts, related QAs (e.g., availability and performance), weaknesses (how to improve?), strengths, and trade-offs</li><li>MapReduce’s</li><li>Pipe-and-Filter’s</li></ul><p><strong>对应章节</strong>：</p><ul><li>第13章：Architectural Tactics and Patterns<ul><li>包括P2P、MapReduce和Pipe-and-Filter模式的定义、基本概念、相关质量属性，以及这些模式的优缺点及权衡分析</li></ul></li></ul><p>4、ATAM (architectural reasons), Participants’ Roles, the usage of Utility Tree.</p><p><strong>对应章节</strong>：</p><ul><li>第21章：Architecture Evaluation<ul><li>详细描述ATAM方法的定义、流程和参与者角色</li></ul></li><li>第16章：Architecture and Requirements<ul><li>提供了Utility Tree的定义及其在捕获架构显著需求（ASRs）中的使用</li></ul></li></ul><p>5、Open discussion. For example:</p><ul><li>The abstract common services tactic is intended to reduce coupling, but it also might reduce cohesion?</li></ul><p><strong>对应章节</strong>：</p><ul><li>第13章：Architectural Tactics and Patterns<ul><li>讨论了模式和战术对耦合和内聚性的影响，例如“抽象公共服务战术可能减少耦合，但可能也会降低内聚”</li></ul></li></ul><p>6、Discuss the choice of programming language (an example of choice of technology) and its relation to architecture in general.<br>textbook P409</p><p><strong>对应章节</strong>：</p><ul><li>第3章：The Many Contexts of Software Architecture<ul><li>讨论了技术选择（例如编程语言）对软件架构的影响(软件构架实践英文第三版)。</li></ul></li><li>第22章：Management and Governance<ul><li>涉及架构决策中技术选择的管理和治理问题</li></ul></li></ul><p>软件体系结构概念及ABC</p><p>常见软件体系结构模式及其特点</p><p>软件体系结构的质量属性及其战术（重点！）</p><p>软件体系结构与需求</p><p>软件体系结构设计方法</p><p>软件体系结构与系统实现</p><p>软件体系结构评审方法（ATAM）</p><p>考题类型（大约）</p><ul><li>选择题（30%）</li><li>简答题（30%）</li><li>分析论述题（40%）</li></ul><h2 id="chapt1"><a href="#chapt1" class="headerlink" title="chapt1"></a>chapt1</h2><p>系统的软件体系结构是推理系统所需的一组结构，其中包括软件元素、它们之间的关系以及两者的属性。</p><p>架构是一组软件结构</p><p>结构是由关系连接在一起的一组元素。</p><p>three important categories of architectural structures.</p><h3 id="Module-Structures"><a href="#Module-Structures" class="headerlink" title="Module Structures"></a>Module Structures</h3><p>模块：一些将系统划分为实现单元的结构</p><p>模块被分配了特定的计算职责，并且是编程团队工作分配的基础。</p><p>模块结构体现了如何将系统构建为一组必须构建或采购的代码或数据单元的决策。</p><p>模块结构允许我们回答如下问题：</p><ul><li>分配给每个模块的主要职能职责是什么？</li><li>模块还允许使用哪些其他软件元素？</li><li>它实际上使用和依赖的其他软件是什么？</li><li>哪些模块通过泛化或专业化（即继承）关系与其他模块相关？</li></ul><h3 id="Component-and-connector-Structures"><a href="#Component-and-connector-Structures" class="headerlink" title="Component-and-connector Structures"></a>Component-and-connector Structures</h3><p>运行结构：结构侧重于<strong>元素在运行时相互交互以执行系统功能的方式</strong>。</p><p>组件和连接器结构体现了如何将系统构建为一组<strong>具有运行时行为</strong>（组件）和交互（连接器）的元素的决策。</p><p>组件和连接器视图可帮助我们回答如下问题：</p><ul><li>主要的执行组件是什么，它们在运行时如何交互？ 主要的共享数据存储有哪些？</li><li>系统会复制系统的哪些部分？</li><li>数据如何在系统中进行？</li><li>系统的哪些部分可以并行运行？</li><li>系统的结构是否可以在执行时发生变化，如果是，如何改变？</li></ul><p>组件和连接器视图对于询问有关系统运行时属性（如性能、安全性、可用性等）的问题至关重要。</p><h3 id="Allocation-Structures"><a href="#Allocation-Structures" class="headerlink" title="Allocation Structures"></a>Allocation Structures</h3><p>分配结构描述了从软件结构到系统环境的映射</p><p>分配结构显示软件元素与创建和执行软件的一个或多个外部环境中的元素之间的关系。</p><p>分配与分簿视图可帮助我们回答如下问题：</p><ul><li>每个软件元素在什么处理器上执行？</li><li>在开发、测试和系统构建过程中，每个元素存储在哪些目录或文件中？</li><li>每个软件元素分配给开发团队的是什么？</li></ul><h3 id="Some-Useful-Module-Structures"><a href="#Some-Useful-Module-Structures" class="headerlink" title="Some Useful Module Structures"></a>Some Useful Module Structures</h3><ul><li>Decomposition structure</li><li>Uses structure.</li><li>Layer structure</li><li>Class (or generalization) structure</li><li>Data model</li></ul><h3 id="Some-Useful-C-C-Structures"><a href="#Some-Useful-C-C-Structures" class="headerlink" title="Some Useful C&amp;C Structures"></a>Some Useful C&amp;C Structures</h3><p>所有组件和连接器结构中的关系都是 attachment，显示组件和连接器是如何挂接在一起的。</p><ul><li><h4 id="Service-structure"><a href="#Service-structure" class="headerlink" title="Service structure"></a>Service structure</h4></li></ul><p>服务结构有助于设计一个系统，该系统由可能匿名开发且彼此独立的组件组成。</p><ul><li><h4 id="Concurrency-structure"><a href="#Concurrency-structure" class="headerlink" title="Concurrency structure"></a>Concurrency structure</h4></li></ul><p>此结构有助于确定并行的机会以及可能发生资源争用的位置。 单元是组件 连接器是它们的通信机制。 这些组件被安排到逻辑线程中。</p><p>shared data</p><h3 id="Some-Useful-Allocation-Structures"><a href="#Some-Useful-Allocation-Structures" class="headerlink" title="Some Useful Allocation Structures"></a>Some Useful Allocation Structures</h3><ul><li><h4 id="Deployment-structure"><a href="#Deployment-structure" class="headerlink" title="Deployment structure"></a>Deployment structure</h4></li></ul><p>部署结构显示了如何将软件分配给硬件处理和通信元素。</p><ul><li><h4 id="Implementation-structure"><a href="#Implementation-structure" class="headerlink" title="Implementation structure"></a>Implementation structure</h4></li></ul><p>此结构显示了软件元素（通常是模块）如何映射到系统的开发、集成或配置控制环境中的文件结构。</p><h3 id="Architectural-Patterns"><a href="#Architectural-Patterns" class="headerlink" title="Architectural Patterns"></a>Architectural Patterns</h3><p>模式：架构元素的组合以解决特定问题</p><p>体系结构模式描述了用于解决问题的<strong>元素类型及其交互形式</strong>。</p><p>常见的模块类型模式</p><p>Layered 模式（multi-layer）：当软件元素之间的使用关系严格单向时，就会出现一个层系统。 层是一组连贯的相关功能。 这种模式的许多变体在实践中发生，减少了结构限制。</p><p>常见的组件和连接器类型模式：</p><ul><li>共享数据（或存储库）模式。 此模式包含创建、存储和访问持久性数据的组件和连接器。 存储库通常采用（商业）数据库的形式。 连接器是用于管理数据的协议，例如 SQL。</li><li>客户端-服务器模式。 组件是客户端和服务器。 连接器是它们之间共享的协议和消息，用于执行系统的工作。</li></ul><p>常见分配模式：</p><ul><li>多层模式（multi-tier） ：描述如何在硬件和软件的不同子集中分发和分配系统组件，并通过某种通信介质进行连接。 此模式专门用于通用部署 （软件到硬件分配） 结构。</li><li>能力中心模式和平台模式 ：这些模式专门用于软件系统的工作指派结构。 在能力中心中，根据现场的技术或领域专业知识将工作分配给现场。 在 platform 中，一个站点的任务是开发软件产品线的可重用核心资产，而其他站点则开发使用核心资产的应用程序。</li></ul><h2 id="chapt3context"><a href="#chapt3context" class="headerlink" title="chapt3context"></a>chapt3context</h2><p>软件架构的context</p><p>technical: The most important technical context factor is the set of quality attributes that the architecture can help to achieve.</p><p>project life cycle: They tell the members of the team what to do next</p><p>•There are four dominant software development processes:</p><ul><li>–Waterfall</li><li>–Iterative</li><li>–Agile</li><li>–Model-driven development</li></ul><p>business</p><p>professional</p><h3 id="Architectures-exist-in-four-different-contexts"><a href="#Architectures-exist-in-four-different-contexts" class="headerlink" title="Architectures exist in four different contexts."></a><strong>Architectures exist in four different contexts.</strong></h3><p>–Technical. The technical context includes the achievement of quality attribute requirements.</p><p>–Project life cycle. Regardless of the software development methodology you use, you must perform specific activities.</p><p>– Business. The system created from the architecture must satisfy the business goals of a wide variety of stakeholders.</p><p>–Professional. You must have certain skills and knowledge to be an architect, and there are certain duties that you must perform as an architect.</p><h3 id="Architecture’s-Influence"><a href="#Architecture’s-Influence" class="headerlink" title="Architecture’s Influence"></a>Architecture’s Influence</h3><p>需求、业务和社会因素以及技术因素共同影响架构。<br>架构的存在反过来也会影响技术、业务和社会环境，进而影响未来的架构。</p><h2 id="chapt4Quality-Attributes"><a href="#chapt4Quality-Attributes" class="headerlink" title="chapt4Quality Attributes"></a>chapt4Quality Attributes</h2><p>质量属性</p><p><strong>质量属性（Quality Attributes）<strong>是软件系统在运行、开发和维护过程中需要</strong>具备的特性或能力</strong>，用于衡量系统的非功能性需求（Non-Functional Requirements, NFR）。这些属性反映了系统“如何”完成其功能，而不仅仅是“做什么”。</p><p><strong>运行时质量属性</strong><br>这些属性关注系统在运行期间表现出的行为，例如：<br>性能（Performance）：系统能在多快的时间内完成任务？<br>可用性（Availability）：系统是否能够持续运行且可用？<br>安全性（Security）：系统是否能防止未经授权的访问和攻击？<br>可扩展性（Scalability）：系统是否能够应对增长的负载？<br>可靠性（Reliability）：系统在多大程度上能够避免失败？</p><p><strong>开发和维护相关的质量属性</strong><br>这些属性关注系统在开发、测试和维护过程中的特性，例如：<br>可修改性（Modifiability）：系统是否易于修改以适应新需求？<br>可测试性（Testability）：系统是否易于测试以确保其功能和性能？<br>可部署性（Deployability）：系统是否易于部署到目标环境？<br>可移植性（Portability）：系统能否轻松移植到不同的硬件或平台？</p><p>三个问题</p><ul><li><p><strong>定义不可测试性问题</strong></p></li><li><p>问题：软件质量属性的传统定义通常过于模糊，缺乏具体的、可量化的标准。例如，简单地说一个系统是“可修改的”没有明确说明如何验证这一点。</p></li><li><p><strong>关注点分类争议</strong></p></li><li><p>问题**：在讨论系统质量问题时，经常会花费大量时间争论某个问题属于哪种质量属性的范畴。例如，某种系统失败是否是“可用性”的问题，还是“安全性”或“性能”的问题。</p></li><li><p><strong>领域内词汇分裂</strong></p></li><li><p><strong>问题</strong>：每种质量属性的社区（如安全性、可用性、性能）往往发展出自己独特的术语和方法，这导致不同领域的专业人员难以交流。</p></li></ul><p><strong>质量属性考虑</strong></p><p>前两个问题的解决方案是使用质量属性场景作为描述质量属性的手段</p><p>第三个问题的解决方案是提供对每个属性的讨论。</p><p>Our representation of quality attribute scenarios has these parts:（质量属性场景的表示）！！！<br>1、Stimulus刺激：当到达系统时要求响应的条件，例如故障：遗漏、崩溃、时间错误、响应错误<br>2、Stimulus source：实体，人类、计算机或其它执行器，例如内部&#x2F;外部：人员、硬件、软件、物理基础设施、物理环境<br>3、Response 响应，例如防止故障成为故障，从故障中恢复（ 禁用导致故障的事件源<br>在维修期间暂时不可用<br>修复或掩盖故障&#x2F;故障，或遏制其造成的损害<br>在进行修复时以降级模式运行）<br>4、Response measure响应度量：</p><p>the system must be available的时间或时间间隔<br>可用性百分比（例如 99.999%）<br>检测故障的时间<br>恢复故障的时间<br>系统可以处于降级模式的时间或时间间隔<br>系统防止或处理而不会出现故障的某类故障的比例（例如，99%）或比率（例如，每秒最多 100 个）</p><p>5、Environment：正常运行、启动、停机、修复模式、降级运行、过载运行<br>6、Artifact构件：例如系统的处理器、通信通道、持久存储、进程</p><h3 id="tactics"><a href="#tactics" class="headerlink" title="tactics"></a>tactics</h3><p>There are a collection of primitive design techniques that an architect can use to achieve a quality attribute response</p><p>实现对质量属性的响应的基本设计技术</p><p>策略是一些具体的、可复用的设计技术，它们是实现某种质量属性（如性能、可靠性或可用性）所需的基础方法。</p><p><strong>与设计模式的区别：</strong></p><p>设计模式是对常见设计问题的高层解决方案，通常适用于代码级别的开发。<br>策略则更接近于架构层面，是实现质量属性的基础手段。例如，为了提高系统的可用性，可以采用冗余策略；为了提高性能，可以使用缓存策略</p><h3 id="设计决策分类"><a href="#设计决策分类" class="headerlink" title="设计决策分类"></a><strong>设计决策分类</strong></h3><p><strong>责任分配：</strong></p><p>确定重要职责，包括基本系统功能、架构基础设施和质量属性的满意度。<br>确定如何将这些职责分配给非运行时和运行时元素（即模块、组件和连接器）。</p><p><strong>协调模型：</strong></p><p>确定系统中必须协调或者禁止协调的元素；确定协调的属性，例如及时性、时效性、完整性、正确性和一致性（timeliness, currency, completeness, correctness, and consistency）；选择实现这些属性的通信机制。</p><p><strong>数据模型：</strong></p><p>选择主要数据抽象、它们的操作及其属性；一致解释数据所需的元数据；数据的组织（这包括确定数据是要保存在关系数据库、对象集合中，还是同时保存在两者中）</p><p><strong>资源管理</strong>：</p><p>确定必须管理的资源并确定每个资源的限制<br>确定哪些系统元素管理每个资源<br>确定资源共享方式以及当存在竞争时采用的仲裁策略<br>确定饱和度对不同资源的影响。</p><p><strong>架构元素之间的映射</strong>：</p><p>模块和运行时元素彼此之间的映射（从每个模块创建的运行时元素；包含每一个运行时元素的模块）；</p><p>运行时元素到处理器的分配；</p><p>将数据模型中的item分配给数据stores；</p><p>模块和运行时元素到交付单元的映射</p><p><strong>绑定时间决策</strong>：</p><p>绑定时间指的是某项决策何时生效或固定下来的时机</p><p>职责分配：可以在构建时（Build Time）决定模块的选择。</p><p>协作模型选择：可以设计为运行时（Run Time）协商协议</p><p>资源管理：系统可以设计为在运行时接受新设备</p><p>技术选择：可以构建一个支持自动化的应用分发平台</p><p><strong>技术选择</strong>：</p><p>确定哪些技术可用于实现其他类别中做出的决策<br>确定支持此技术的工具（IDE、模拟器、测试工具等）是否足够<br>确定内部对技术的熟悉程度和外部支持程度（例如课程、教程、示例、承包商的可用性）<br>确定选择技术（如所需的协调模型或受约束的资源管理机会）的副作用<br>确定新技术是否与现有技术堆栈兼容</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>系统的要求分为三类。<br>功能的。通过在设计中包含一组适当的职责来满足这些要求。<br>Quality 属性。体系结构的结构和行为满足这些要求。<br>约束。约束是已经做出的设计决策。</p><h2 id="chapt5-availability"><a href="#chapt5-availability" class="headerlink" title="chapt5 availability"></a>chapt5 availability</h2><p>define：系统在发生故障时可供使用的能力。必须识别（或阻止）故障，然后系统必须做出响应。</p><p>availability是软件的一种属性，通过减少故障来最大限度地减少服务中断时间。</p><h3 id="Availability-Tactics"><a href="#Availability-Tactics" class="headerlink" title="Availability Tactics"></a>Availability Tactics</h3><p>可用性策略是软件体系结构中的一组设计手段，用来提高系统的可用性。这些策略的目标是最小化系统停机时间，包括预防故障、检测故障、恢复故障等方面的设计方法。</p><p>检测策略取决于从各种组件中检测生命迹象。<br>恢复策略是重试操作或维护冗余数据或计算。<br>预防策略取决于从服务中删除元素或限制故障范围。<br>所有可用性策略都涉及协调模型。</p><p>prevent：</p><p>冗余（Redundancy）：<br>通过添加多余的硬件或软件组件，避免单点故障。例如，双机热备、分布式系统中的副本。<br>隔离（Isolation）：<br>限制故障的传播，确保一个组件的失效不会影响其他组件。例如，分区存储。<br>输入校验（Input Validation）：<br>验证用户输入或外部数据以防止恶意输入导致的系统崩溃。<br>Removal Out Service：暂时将系统组件置于停止服务状态。<br>事务：捆绑状态更新，以便在分布式组件之间交换的异步消息是原子的、一致的、隔离的和持久的。<br>预测模型：监控过程的健康状况，以确保系统在标称参数范围内运行;当检测到可预测未来可能故障的情况时，采取纠正措施。</p><p>detection：</p><p>心跳机制（Heartbeat）：<br>定期发送信号以确认组件的运行状态。例如，分布式系统中的健康检查。<br>异常检测（Exception Detection）：<br>捕获并处理程序运行中抛出的异常。<br>监控（Monitoring）：<br>系统监控器可以检测网络或其他共享资源中的故障或拥塞，例如拒绝服务攻击。<br>Ping&#x2F;echo：节点之间交换的异步请求&#x2F;响应消息对，用于确定通过关联网络路径的可达性和往返延迟。<br>时间戳（timestamp）：用于检测不正确的<strong>事件序列</strong>，主要在分布式消息传递系统中。<br>Sanity Checking（合理性检查）：用于验证组件的操作或输出是否有效且合理。<br>Condition Monitoring（条件监控）：用于实时监控过程或设备的条件，或者验证设计中的假设是否仍然有效。<br>Voting（投票机制）：检查多个复制组件的输出是否一致，以判断操作结果的正确性</p><p>recovery：</p><p>重试：如果失败是暂时性的，则重试操作可能会导致成功。<br>Ignore Faulty Behavior：当确定某个消息是虚假消息时，忽略从源发送的消息。<br>Degradation降级：在组件发生故障的情况下保持最关键的系统功能，丢弃不太关键的功能。<br>故障转移（Failover）：<br>当一个组件失效时，自动切换到备用组件。例如，数据库主从切换。<br>重启（Retry&#x2F;Restart）：<br>在故障发生时，自动重试操作或重启服务。例如，容器化应用的自动重启。<br>检查点&#x2F;回滚（Checkpoint&#x2F;Rollback）：<br>定期保存系统状态，在发生故障时回滚到最近的正常状态。<br>Active Redundancy (hot spare)主动冗余（热备用）：保护组中的所有节点并行接收和处理相同的输入，从而允许冗余备用节点保持与主动节点的同步状态。<br><strong>被动冗余（热备用）</strong>：只有保护组的主动成员处理输入流量;他们的职责之一是为冗余的备用设备提供定期状态更新。（保护组是一组节点，其中一个或多个节点处于“活动”状态，其余节点用作冗余备用节点。）<br><strong>备用（冷备用）</strong>：备用系统在平时完全关闭或非活动状态，只有当主系统故障时才被启动和加载。在冗余备用设备投入使用之前，将对冗余备用设备启动开机重置过程。</p><table><thead><tr><th>冗余类型</th><th>状态</th><th>切换时间</th><th>成本</th><th>适用场景</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>主动冗余</strong></th><th>所有冗余系统活动</th><th>无缝切换</th><th>高</th><th>高可用性、高可靠性要求场景</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>被动冗余</strong></th><th>备用系统保持同步</th><th>短暂中断</th><th>中等</th><th>可容忍短暂中断的关键系统</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>冷备用</strong></th><th>备用系统非活动</th><th>长时间中断</th><th>低</th><th>成本敏感的非实时系统或灾备场景</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>Shadow（影子模式）：在一个组件经过故障修复或升级后，先让其以“影子模式”运行一段时间，监控其行为，但不直接影响系统的关键功能。只有在确认其正常运行后，才将其恢复为主用组件<br>State Resynchronization（状态重新同步）：用于支持主动冗余（Active Redundancy）和被动冗余（Passive Redundancy）的一种技术。它通过将主用组件的状态信息同步到备用组件，确保备用组件随时能够接管工作。<br><strong>Escalating Restart（逐级重启）</strong>：通过逐步增加重启范围的方式，从更细粒度的组件重启开始，逐步扩大重启范围，尽量减少对系统服务的影响。<br>Non-stop Forwarding（不停转发）：将功能分为**管理（supervisory）<strong>和</strong>数据处理（data forwarding）**两部分。在管理功能（如路由协议）失效时，数据处理功能继续运行，确保核心服务不中断，同时尝试恢复管理功能。<br>Removal From Service（移出服务）</p><h3 id="Design-Checklist-for-Availability-高可用性设计检查清单"><a href="#Design-Checklist-for-Availability-高可用性设计检查清单" class="headerlink" title="Design Checklist for Availability (高可用性设计检查清单)"></a>Design Checklist for Availability (高可用性设计检查清单)</h3><p><strong>Allocation of Responsibilities</strong>：<br>确定需要高可用性的系统职责。 <strong>确保已分配其他责任</strong>来检测遗漏、崩溃、错误计时或错误响应。（ omission, crash, incorrect timing, or incorrect response）<br><strong>确保有责任：</strong></p><ul><li>记录故障</li><li>通知相应的实体（人员或系统）</li><li>禁用导致故障的事件源</li><li>暂时不可用</li><li>修复或掩盖故障</li><li>在 Degraded 模式下运行</li></ul><p><strong>Coordination Model</strong>：<br>确定需要高可用性的系统职责</p><ul><li>确保协调机制可以检测到遗漏、崩溃、不正确的计时或不正确的响应。 例如，考虑是否有必要保证交付。协调是否会在通信降级的情况下工作？</li><li>确保协调机制能够记录故障、通知适当的实体、禁用导致故障的事件源、修复或屏蔽故障或在降级模式下运行</li><li>确保协调模型支持替换工件 （处理器、通信通道、持久存储和进程）。 例如，更换服务器是否允许系统继续运行？</li><li>确定协调是否在通信降级、启动&#x2F;关闭、修复模式或过载操作的情况下工作。例如，协调模型可以承受多少信息丢失，会产生什么后果？</li></ul><p><strong>Data Model</strong></p><ul><li>确定系统的哪些部分需要具有高可用性。在这些部分中，<strong>确定哪些数据抽象可能导致</strong>遗漏错误、崩溃、不正确的 计时行为 或不正确的响应。</li><li>对于这些数据抽象、操作和属性，请确保它们可以被禁用、暂时不可用或在发生故障时被修复或屏蔽。</li><li>例如，确保在服务器暂时不可用时缓存写入请求，并在服务器恢复服务时执行写入请求。</li></ul><p><strong>Mapping Among Architectural Elements</strong><br>确定哪些工件（处理器、通信通道、存储、进程）可能会产生故障：遗漏、崩溃、不正确的计时或不正确的响应。<br><strong>确保架构元素的映射 （或重新映射） 足够灵活</strong>，以允许从故障中恢复。这可能涉及对</p><ul><li>故障处理器上的哪些进程需要在运行时重新分配</li><li>在运行时可以激活或重新分配哪些处理器、数据存储或通信通道</li><li>更换单元如何为故障处理器或存储上的数据提供服务</li><li>根据提供的交货单位重新安装系统的速度</li><li>如何（重新）将运行时元素分配给处理器、通信通道和数据存储</li></ul><p><strong>Resource Management</strong><br>确定在出现故障时继续运行所需的关键资源：遗漏、崩溃、时间错误或响应错误。<br>确保在发生故障时有足够的剩余资源来</p><ul><li>记录故障;</li><li>通知适当的实体（人员或系统）;</li><li>禁用导致故障的事件源;修复或掩盖故障&#x2F;故障;</li><li>在启动、关闭、修复模式、降级操作和过载操作下正常运行。</li></ul><p>确定关键资源的可用性时间、在指定时间间隔内必须可用的关键资源、关键资源可能处于降级模式的时间间隔以及关键资源的修复时间。确保关键资源在这些时间间隔内可用。<br>例如，确保输入队列足够大，以便在服务器发生故障时缓冲预期的消息，以便消息不会永久丢失。</p><p><strong>Binding Time</strong><br>确定绑定架构元素的方式和时间。如果使用晚绑定在组件之间切换，而这些组件本身可能成为故障来源（例如进程、处理器或通信渠道），需要确保所选的高可用性策略能够充分应对由所有来源引入的故障。</p><p><strong>Choice of Technology</strong><br>确定可以（帮助）检测故障、从故障中恢复、重新引入故障组件的可用技术。<br>确定哪些技术可以帮助响应故障（例如，事件记录器）。<br>确定所选技术本身的可用性特征：它们可以从哪些故障中恢复？ 它们可能会给系统带来哪些故障？</p><h2 id="Chapter-6-Interoperability"><a href="#Chapter-6-Interoperability" class="headerlink" title="Chapter 6: Interoperability"></a>Chapter 6: Interoperability</h2><p>互操作性(质量属性之一)</p><p>互操作性是关于两个或多个系统可以有效地交换有意义信息的程度。</p><h3 id="Interoperability-General-Scenario"><a href="#Interoperability-General-Scenario" class="headerlink" title="Interoperability General Scenario"></a>Interoperability General Scenario</h3><p>Source:  A system</p><p>Stimulus：系统件交换信息的请求</p><p>Artifact：希望互操作的系统</p><p>Environment:希望互操作的系统在运行时被发现或在运行时之前已知</p><p>Response:以下一项或多项：</p><ul><li>请求被（适当地）拒绝，并通知相应的实体（人员或系统）</li><li>请求被（适当地）接受，信息交换成功</li><li>请求由一个或多个涉及的系统记录</li></ul><p>Response Measure:以下一项或多项：</p><ul><li>正确处理的信息交换百分比</li><li>正确拒绝的信息交换百分比</li></ul><h3 id="Goal-of-Interoperability-Tactics"><a href="#Goal-of-Interoperability-Tactics" class="headerlink" title="Goal of Interoperability Tactics"></a>Goal of Interoperability Tactics</h3><p>为了使两个或更多系统有效地交换信息，它们必须满足以下条件</p><p>相互了解：<br>这就是“定位策略（locate tactics）”的目的。系统需要知道彼此的存在，并能够发现对方的资源、服务或数据。这通常通过服务发现机制、注册中心等方法实现。</p><p>语义上有意义的信息交换：<br>这就是“管理接口策略（manage interfaces tactics）”的目的。系统之间交换的信息必须是语义明确、双方能够理解和使用的。这涉及到数据格式、协议和语义的一致性，确保交换的信息对每个系统都具有相同的意义。</p><p><strong>信息交换</strong>的两个关键方面：按正确顺序提供服务,将信息转换为对方可接受的形式</p><h3 id="Interoperability-Tactics"><a href="#Interoperability-Tactics" class="headerlink" title="Interoperability Tactics"></a>Interoperability Tactics</h3><p>Discover service:</p><p>通过搜索已知的目录服务来定位服务。此位置过程中可能存在多个间接级别 - 即一个已知位置指向另一个位置，而该位置又可以搜索该服务。</p><p>Orchestrate（协调）:</p><p>使用控制机制来协调、管理和按顺序调用服务。当系统需要以复杂的方式进行交互以完成复杂任务时，就会使用协调策略。</p><p>Tailor Interface（定制接口）:</p><p>对接口的功能进行修改，增加或移除某些能力，比如翻译、缓冲或数据平滑等。来优化系统间的交互，确保数据在交换过程中得到适当的处理和转换</p><h3 id="Design-Checklist-for-Interoperability"><a href="#Design-Checklist-for-Interoperability" class="headerlink" title="Design Checklist for Interoperability"></a>Design Checklist for Interoperability</h3><p><strong>Allocation of</strong> <strong>Responsibilities</strong><br>确定您的哪些系统职责需要与其他系统进行互操作；<br>确保已分配责任于检测与已知或未知外部系统进行Interoperability的请求<br>确保已将责任分配给</p><ul><li>接受请求</li><li>交易所信息</li><li>拒绝请求</li><li>通知相应的实体（人员或系统）</li><li>记录请求（为了在不受信任的环境中实现互操作性，必须记录不可否认性）</li></ul><p><strong>Coordination Model</strong><br>确保协调机制能够满足关键质量属性要求。性能注意事项包括：</p><ul><li>网络上的流量，既由您控制的系统创建，也由不受您控制的系统生成。</li><li>系统发送的消息的及时性</li><li>您的系统发送的消息的实时性</li><li>消息到达时间的抖动。</li></ul><p>确保您控制的所有系统都对协议和底层网络做出与不受您控制的系统一致的假设</p><p><strong>Data Model</strong><br>确定可在互操作系统之间交换的主要数据抽象的语法和语义。<br>确保这些主要数据抽象与来自互操作系统的数据一致。 （如果您的系统的数据模型是机密的，并且不得公开，则您可能必须对与之互操作的系统的数据抽象进行转换。）</p><p><strong>Mapping Among Architectural Elements</strong><br>对于互操作性，关键的映射是组件到处理器的映射。除了确保与外部通信的组件被部署在可以连接到网络的处理器上的必要性之外，主要考虑因素还涉及满足通信的安全性、可用性和性能要求。</p><p><strong>Resource Management</strong><br>确保与其他系统的互操作（接受请求和&#x2F;或拒绝请求）永远不会耗尽关键的系统资源<br>确保互操作的通信要求所施加的资源负载是可接受的。<br>确保如果互操作要求在参与系统之间共享资源，则要制定适当的仲裁策略。</p><p><strong>Binding Time</strong><br>确定可以互操作的系统，以及它们何时相互了解。<br>对于您控制的每个系统：</p><ul><li>确保它具有处理绑定到已知和未知外部系统的策略。</li><li>确保它具有拒绝不可接受的绑定并记录此类请求的机制。</li><li>在后期绑定的情况下，请确保机制将支持发现相关的新服务或协议，或使用所选协议发送信息。</li></ul><p><strong>Choice of Technology</strong><br>考虑旨在支持互操作性的技术，例如 Web 服务</p><h2 id="Chapter-7-Modifiability"><a href="#Chapter-7-Modifiability" class="headerlink" title="Chapter 7: Modifiability"></a>Chapter 7: Modifiability</h2><p>可修改性涉及更改以及进行更改的时间或金钱成本，包括此修改对其他功能或质量属性的影响程度。 降低更改成本的策略包括缩小模块、增加内聚和减少耦合。延迟绑定还将降低进行更改的成本。</p><h3 id="Modifiability-General-Scenario"><a href="#Modifiability-General-Scenario" class="headerlink" title="Modifiability General Scenario"></a>Modifiability General Scenario</h3><table><thead><tr><th><strong>Portion  of      Scenario</strong></th><th><strong>Possible  Values</strong></th></tr></thead><tbody><tr><td>Source</td><td>End  user, developer, system administrator</td></tr><tr><td>Stimulus</td><td>用于添加&#x2F;删除&#x2F;修改功能或更改质量属性、容量或技术的指令</td></tr><tr><td>Artifacts</td><td>Code,  data, interfaces, components, resources, configurations, …</td></tr><tr><td>Environment</td><td>Runtime,  compile time, build time, initiation time, design time</td></tr><tr><td>Response</td><td>One  or more of the following:  ·make modification   ·test modification  ·deploy modification</td></tr><tr><td>Response       Measure</td><td>Cost  in terms of:  ·number, size, complexity of affected  artifacts  ·effort  ·calendar time  ·money (direct outlay or opportunity  cost)  ·extent to which this modification  affects other functions or quality attributes  ·new defects introduced</td></tr></tbody></table><h3 id="Modifiability-Tactics"><a href="#Modifiability-Tactics" class="headerlink" title="Modifiability Tactics"></a>Modifiability Tactics</h3><p>Goal：控制进行更改的复杂性，以及进行更改的时间和成本。</p><p><strong>Reduce Size of a Module</strong><br>拆分模块：如果被修改的模块包含大量功能，则修改成本可能会很高。将模块细化为几个较小的模块应该可以降低未来更改的平均成本。</p><p><strong>Increase Cohesion</strong><br>提高语义一致性：模块中的所有职责应为单一目标或功能域服务。如果模块内的不同职责具有明显不同的目标，应将其分离，以保持代码的清晰性、模块化和内聚性。</p><p><strong>Reduce Coupling</strong><br><em>封装 (Encapsulate)</em>：封装为模块引入了一个显式接口，该接口包括 API 和相关职责，例如“对输入参数进行语法转换以适应内部表示”。<br><em>使用中介 (Use an Intermediary)</em>：如果职责 A 和职责 B 之间存在依赖关系（例如，执行 A 前必须先执行 B），可以通过引入一个中介来打破这种依赖。<br><em>限制依赖 (Restrict Dependencies)</em>：限制一个模块可以交互或依赖的其他模块数量<br><em>重构 (Refactor)</em>：当两个模块因重复的功能而同时受到相同的修改时，需要对这些模块进行重构，以消除重复。<br>*抽象公共服务 (Abstract Common Services)：*当两个模块提供的服务类似但不完全相同时，可以通过实现一个更通用（抽象）的形式，将这些服务统一起来。</p><p><strong>Defer Binding</strong><br>迟绑定<br>一般来说，在生命周期中，我们可以绑定值的时间<strong>越晚越好</strong>。<br>延迟绑定的机制往往成本更高。</p><h3 id="Design-Checklist-for-Modifiability"><a href="#Design-Checklist-for-Modifiability" class="headerlink" title="Design Checklist for Modifiability"></a>Design Checklist for Modifiability</h3><p><strong>Allocation of Responsibilities</strong>：<br>通过分析技术、法律、社会、业务以及客户需求等方面的变化，确定哪些变化或变化类别可能会发生。<br>针对每个潜在变化或变化类别：</p><ul><li>确定需要新增、修改或删除的职责，以适应这些变化。</li><li>确定哪些其他职责受更改影响。</li><li>将职责分配到模块时，尽可能遵循以下原则：<ul><li>将可能同时发生变化（或被该变化影响）的职责集中在同一个模块。</li><li>将可能在不同时间发生变化的职责分配到不同模块中。</li></ul></li></ul><p><strong>Coordination Model</strong><br>分析哪些功能或质量属性可能在运行时发生变化，以及这些变化如何影响模块间的协调，例如：</p><ul><li>信息的内容是否会在运行时改变？</li><li>通信协议是否会在运行时发生变化<ul><li>如果这些变化确实会发生，确保这些变化仅影响少量模块</li></ul></li></ul><p>识别可能发生变化的设备、协议和通信路径<br>为可修改性的元素选择合适的协调模型例如：</p><ul><li><strong>发布&#x2F;订阅模型</strong>（Publish&#x2F;Subscribe）：模块间通过事件或消息进行解耦。</li><li><strong>延迟绑定</strong>（如企业服务总线，Enterprise Service Bus）：在运行时动态绑定模块或服务。</li><li><strong>限制依赖</strong>（如广播机制，Broadcast）：通过减少直接依赖关系降低耦合</li></ul><p><strong>Data Model</strong><br>确定可能发生的变化或变化类别：分析数据抽象（数据模型）的结构、操作和属性中哪些部分可能发生变化或可能的变化类别。；确定这些变化是否涉及数据抽象的<strong>创建</strong>、<strong>初始化</strong>、<strong>持久化</strong>、<strong>操作</strong>、<strong>转换</strong>或<strong>销毁</strong>。</p><p>确定变化的操作者，对于每种变化或变化类别，确定变化是由以下哪类人执行的：最终用户、系统管理员、开发者*</p><p>针对每种潜在变化或变化类别：</p><ul><li>确定需要<strong>新增、修改或删除</strong>的数据抽象。</li><li>确定这些数据抽象的创建、初始化、持久性、操作、转换或销毁是否会发生任何更改，</li><li>确定其他数据抽象是否受到这些变化的影响。对于这些额外的抽象，分析其受影响的方面是否涉及操作、属性、创建、初始化、持久化、操作、转换或销毁。</li><li>确保数据抽象的分配能够最大限度地减少潜在更改对抽象的修改的数量和严重性</li></ul><p>设计数据模型时，确保分配到同一数据模型元素中的数据项在变化时能够一起被修改。</p><p><strong>Mapping Among Architectural Elements</strong><br>确定功能映射到计算机元素的方式是否需要更改<br>计算机元素包括：进程（processes）、线程（threads）、处理器（processors）等。<br>这些更改可能发生在以下阶段：运行时（runtime）、编译时（compile time）、设计时（design time）、或构建时（build time）。</p><p>评估为适应功能或质量属性的新增、删除或修改所需的更改范围， 这可能涉及确定，例如： 执行依赖关系 将数据分配到数据库 将运行时元素分配给进程、线程或处理器</p><p>确保使用利用映射决策的延迟绑定的机制执行此类更改。</p><p><strong>Resource Management</strong><br>确定添加、删除或修改 responsibility 或 quality 属性将如何影响资源使用。 例如，这包括：</p><ul><li>确定哪些更改可能会引入新资源或删除旧资源或影响现有资源使用情况。</li><li>确定哪些资源限制将发生变化以及如何改变</li></ul><p>确保修改后的资源足以满足系统要求。<br>封装所有资源管理器，并确保这些资源管理器使用的实现的策略本身是封装的，并且绑定尽可能地延迟。</p><p><strong>Binding Time</strong><br>对于每个更改或更改类别 ：</p><ul><li>确定需要进行更改的最晚时间。</li><li>选择在所选时间提供适当功能的延迟绑定机制）。</li><li>确定引入机制的成本以及使用所选机制进行更改的成本</li><li>不要引入太多的绑定选项，以免阻碍更改，因为选项之间的依赖关系是复杂且未知的。</li></ul><p><strong>Choice of Technology</strong><br>确定您的技术选择使哪些修改更容易或更难。</p><p>您的技术选择是否有助于进行、测试和部署修改？ 修改您选择的技术本身有多容易（如果其中一些技术发生变化或过时）？<br>选择您的技术以支持最可能的修改。例如，Enterprise Service Bus 可以更轻松地更改元素的连接方式，但可能会引入供应商锁定。</p><h2 id="chapt8Performance"><a href="#chapt8Performance" class="headerlink" title="chapt8Performance"></a>chapt8Performance</h2><p>描述可能发生的事件（以及它们何时可能发生）以及系统或元素对这些事件的基于时间的响应是讨论性能的本质<br>Performance 是关于在面对特定类型的需求时管理系统资源以实现可接受的 timing behavior。</p><h3 id="Performance-General-Scenario"><a href="#Performance-General-Scenario" class="headerlink" title="Performance General Scenario"></a>Performance General Scenario</h3><table><thead><tr><th><strong>Portion  of Scenario</strong></th><th><strong>Possible  Values</strong></th></tr></thead><tbody><tr><td>Source</td><td>Internal  or external to the system</td></tr><tr><td>Stimulus</td><td>Arrival  of a periodic, sporadic, or stochastic event周期性、偶发性或随机性事件的到来</td></tr><tr><td>Artifact</td><td>System  or one or more components in the system.</td></tr><tr><td>Environment</td><td>Operational  mode: normal, emergency, peak load,  overload.</td></tr><tr><td>Response</td><td>Process  events, change level of service</td></tr><tr><td>Response  Measure</td><td>Latency,  deadline, throughput, jitter, miss rate</td></tr></tbody></table><h3 id="Performance-Tactics"><a href="#Performance-Tactics" class="headerlink" title="Performance Tactics"></a>Performance Tactics</h3><p>goal：在某个基于时间的约束内对到达系统的事件生成响应。</p><p><strong>Control Resource Demand</strong>（控制资源需求）<br>Manage Sampling Rate（管理采样率）：如果可以降低捕获数据流的采样频率，则可以减少系统的负载，但通常会伴随着一定程度的精度或保真度损失<br>Limit Event Response（限制事件响应）：通过设置事件处理的最大频率，只处理一定速率范围内的事件，确保系统在处理事件时更加可预测，从而避免因过多事件导致的性能下降或不可控情况。<br>. Prioritize Events（事件优先级）：如果并非所有事件都同样重要，可以引入优先级方案，根据事件的重要性对其进行排序。<br>Reduce Overhead（减少开销）：使用中间层（如代理、适配器）虽然有助于提高系统的<strong>可修改性（modifiability）</strong>，但会增加处理事件流时的资源消耗。<br>Bound Execution Times（限制执行时间）：对事件的响应设置执行时间的上限，确保每个事件在合理的时间范围内被处理。<br>Increase Resource Efficiency（提高资源效率）：通过改进关键区域的算法，提高资源的利用率，从而减少处理时间和延迟。</p><p><strong>Manage Resources</strong><br>Increase Resources（增加资源）：通过引入更快的处理器、增加处理器数量、扩展内存容量或提升网络速度，可以有效减少系统的延迟。<br>Increase Concurrency（增加并发）：通过并行处理请求，可以减少阻塞时间，提高资源利用效率。<br>Maintain Multiple Copies of Computations（维护多个计算副本）：通过维护多个计算副本（即复制），可以减少因所有计算集中在单一服务器上而导致的资源争用。<br>Maintain Multiple Copies of Data（维护多个数据副本）：通过在不同存储设备上保存数据副本（可能是完整副本或子集），可以根据存储的访问速度优化数据访问。<br>Bound Queue Sizes（限制队列大小）：控制队列中排队请求的最大数量，从而限制处理这些请求所需的资源。<br>Schedule Resources（资源调度）:当多个任务争用同一资源时，必须通过调度机制对资源进行合理分配。</p><h3 id="Design-Checklist-for-Performance"><a href="#Design-Checklist-for-Performance" class="headerlink" title="Design Checklist for Performance"></a>Design Checklist for Performance</h3><p><strong>Allocation of</strong> <strong>Responsibilities</strong>:<br>系统设计中，某些职责会对性能有直接影响，需要优先关注。这些职责可能与高负载、时间要求、或频繁使用相关。例如：</p><ul><li>数据库查询可能是高负载任务；</li><li>实时事件响应需要时间严格控制；</li><li>用户接口模块可能被频繁调用。</li></ul><p><strong>分析职责相关的性能需求</strong></p><ul><li><strong>瓶颈识别</strong>：需要分析处理这些职责所需的资源，判断是否会出现性能瓶颈。</li><li><strong>线程管理</strong>：对于跨越多个处理器或线程的职责，需要确保线程分配和管理能够高效进行。</li><li><strong>资源管理</strong>：调度共享资源（如缓冲区、缓存），确保不会因资源争用导致性能下降。</li></ul><p><strong>Coordination</strong> <strong>Model</strong><br>确定需要协调的系统元素:系统中有些元素需要彼此协调（无论是直接还是间接的方式），为这些元素选择合适的通信和协调机制。这些机制需要满足以下要求:</p><ul><li>支持可能引入的并发（例如，是否线程安全？）、事件优先级或调度策略。</li><li>确保所需的性能响应能够达到预期。</li><li>能够根据需要处理周期性、随机性或偶发性(<strong>periodic, stochastic, or sporadic</strong> )的事件到达情况。</li><li>拥有适当的通信机制属性，例如：是否有状态（stateful 或 stateless）、是否为同步或异步通信、是否保证消息传递、吞吐量需求或延迟要求。</li></ul><p><strong>Data Model</strong><br>确定数据模型的关键部分：<br>找出数据模型中那些会涉及以下情况的部分：</p><ul><li><strong>高负载</strong>：频繁被访问或操作。</li><li><strong>时间敏感</strong>：需要快速响应的部分。</li><li><strong>使用频繁</strong>：对系统性能产生较大影响的部分。</li><li>影响系统中高负载或时间敏感事件的其他部分。</li></ul><p><strong>对这些数据抽象进行分析</strong>，并确定以下内容：<strong>对这些数据抽象进行分析</strong>，并确定以下内容：</p><ul><li><strong>维护多副本</strong>：评估是否通过为关键数据维护多个副本来提升性能。</li><li><strong>数据分区</strong>：分析将数据进行分区是否能够提升性能。</li><li>减少处理需求：评估是否可以减少在以下操作中对数据抽象的处理需求：数据创建、初始化、持久化、操作、转换、销毁</li><li><strong>增加资源</strong>：判断是否可以通过添加资源（如处理能力或存储）来减少在上述操作中可能出现的瓶颈。</li></ul><p><strong>Mapping Among Architectural Elements</strong><br><strong>在网络负载较重的场景中</strong>，确定是否通过<strong>共置某些组件</strong>可以减少网络负载并提高整体效率<br><strong>确保高计算需求的组件</strong>分配到拥有<strong>最大处理能力的处理器</strong>上。<br><strong>评估并发的可行性</strong>：确定是否可以通过<strong>为某功能分配两个或多个同时运行的组件副本</strong>来引入并发，并显著提高性能。<br><strong>检查控制线程的选择和职责分配</strong>是否会引入性能瓶颈。</p><p><strong>Resource Management</strong><br>确定系统中对性能至关重要的资源：针对这些资源，确保在正常运行和系统过载时均能对它们进行监控和管理。<br><strong>示例</strong>：</p><ul><li>系统元素需要意识到并管理的资源，例如时间和其他性能关键资源。</li><li><strong>进程&#x2F;线程模型</strong>：分析和优化进程及线程分配策略。</li><li><strong>资源优先级和访问控制</strong>：为不同资源设定优先级，并确保访问策略符合性能需求。</li><li><strong>调度和锁定策略</strong>：制定高效的任务调度和锁定机制，以避免竞争和死锁。</li><li><strong>按需部署额外资源</strong>：在负载增加时动态增加资源，以满足性能需求。</li></ul><p><strong>Binding Time</strong><br>对于每个将在<strong>编译后</strong>绑定的元素：</p><ul><li>确定完成绑定所需的时间。</li><li>确定使用后期绑定机制引入的额外开销。</li></ul><p><strong>确保</strong>：这些时间和开销不会对系统的性能造成不可接受的负面影响。</p><p><strong>Choice of Technology</strong><br>您的技术选择是否能够设置并满足严格的实时（硬实时）截止期限？您是否了解该技术在负载下的性能特性和极限？<br><strong>您的技术选择是否具备以下能力</strong>：</p><ul><li>设置调度策略</li><li>设置优先级</li><li>制定减少需求的策略</li><li>分配技术的部分功能到具体处理器上</li><li>设置其他与性能相关的参数</li></ul><p>您的技术选择是否会为高频使用的操作引入过多的额外开销？</p><h2 id="Chapter-9-Security"><a href="#Chapter-9-Security" class="headerlink" title="Chapter 9: Security"></a>Chapter 9: Security</h2><p>安全性是衡量系统保护数据和信息免受未经授权的访问的能力，同时仍向获得授权的人员和系统提供访问权限的指标。</p><p>安全性有三个主要特征，称为 CIA<br>机密性Confidentiality是保护数据或服务免受未经授权的访问的属性。<br>完整性Integrity是指数据或服务不会受到未经授权的操作的属性。<br>可用性Availability 是系统可供合法使用的属性。</p><h3 id="Security-General-Scenario"><a href="#Security-General-Scenario" class="headerlink" title="Security General Scenario"></a>Security General Scenario</h3><table><thead><tr><th>Source</th><th>人类或其他系统，这些可能是已知或未知的攻击来源；攻击者可能来自组织外部或内部。</th></tr></thead><tbody><tr><td>Stimulus</td><td>Unauthorized attempt is made to display  data, change or delete data, access system services, change the system’s  behavior, or reduce availability.</td></tr><tr><td>Artifact   (目标对象)</td><td>System services; data within the  system; a component or resources of the system; data produced or consumed by  the system</td></tr><tr><td>Environment</td><td>系统可能在线或离线、连接或断开网络、位于防火墙后或完全开放、完全运行、部分运行或不运行。</td></tr><tr><td>Response</td><td>系统执行交易时应确保：  数据或服务免受未经授权的访问； 数据或服务未经授权不可被篡改； 交易各方可被验证身份； 交易各方不能否认其参与； 数据、资源和服务对合法使用者可用。    系统通过以下方法跟踪其内部活动：  记录访问或修改情况； 记录尝试访问数据、资源或服务的情况； 在发生明显攻击时通知相关实体（如人或系统）。</td></tr><tr><td>Response      Measure</td><td>系统的具体组件或数据值被攻陷的程度； 攻击被检测所花费的时间； 阻止的攻击数量； 从成功的攻击中恢复所需的时间； 某一特定攻击使数据暴露的程度。</td></tr></tbody></table><h3 id="Security-Tactics"><a href="#Security-Tactics" class="headerlink" title="Security Tactics"></a>Security Tactics</h3><h4 id="Detect"><a href="#Detect" class="headerlink" title="Detect"></a><strong>Detect</strong></h4><p><strong>Detect Intrusion (检测入侵)</strong><br>通过将系统内部的网络流量或服务请求模式与存储在数据库中的已知恶意行为 malicious behavior 模式或签名进行比较，来检测潜在的入侵行为。</p><p><strong>Detect Service Denial (检测服务拒绝)</strong><br>将进入系统的网络流量模式或签名与已知的拒绝服务（DoS）攻击的历史记录进行比较，来识别可能的服务拒绝攻击。</p><p><strong>Verify Message Integrity (验证消息完整性)</strong><br>利用校验和或哈希值等技术，验证消息、资源文件、部署文件及配置文件的完整性，确保其未被篡改。</p><p><strong>Detect Message Delay (检测消息延迟)</strong><br>通过检查消息的传递时间，可以发现异常的延迟行为，从而检测可疑（suspicious）的时间行为模式。</p><h4 id="Resist"><a href="#Resist" class="headerlink" title="Resist"></a>Resist</h4><p><strong>Identify Actors (识别参与者)</strong><br>确定系统中所有外部输入的来源。</p><p><strong>Authenticate Actors (认证参与者)</strong><br>确保参与者（如用户或远程计算机）确实是其声称的身份。</p><p><strong>Authorize Actors (授权参与者)</strong><br>确保经过认证的参与者拥有访问或修改数据或服务的权限。</p><p><strong>Limit Access (限制访问)</strong><br>限制对资源（如内存、网络连接或访问点）的访问权限。</p><p><strong>Limit Exposure (限制暴露)</strong><br>通过减少系统的攻击面，例如尽可能减少访问点数量，最小化风险。</p><p><strong>Encrypt Data (加密数据)</strong><br>对数据和通信应用某种形式的加密技术以保护信息安全。</p><p><strong>Separate Entities (分离实体)</strong><br>通过以下方式将实体分离：</p><ul><li>使用不同网络连接的物理服务器</li><li>虚拟机隔离</li><li>使用“物理隔离”（如无网络连接的环境）</li></ul><p>备注：分离机制可以降低攻击扩散的可能性，例如将敏感服务部署在隔离的物理或虚拟环境中</p><p><strong>Change Default Settings (更改默认设置)</strong><br>强制用户修改默认分配的设置。</p><h4 id="React-to-Attacks"><a href="#React-to-Attacks" class="headerlink" title="React to Attacks"></a>React to Attacks</h4><p><strong>Revoke Access (撤销访问)</strong><br>在怀疑存在攻击时，即使是通常合法的用户和用途，也应限制对敏感资源的访问权限。</p><p><strong>Lock Computer (锁定计算机)</strong><br>如果多次尝试访问资源均失败，限制对该资源的访问。</p><p><strong>Inform Actors (通知相关方)</strong><br>当怀疑或检测到攻击时，通知操作员、其他人员或协作系统。</p><h4 id="Recover-From-Attacks"><a href="#Recover-From-Attacks" class="headerlink" title="Recover From Attacks"></a>Recover From Attacks</h4><p>除了用于恢复失败资源的可用性策略外，还包括<strong>审计</strong>：<br><strong>审计 (Audit)</strong>：记录用户和系统的操作及其影响，以便追踪行为并识别攻击者。</p><h3 id="Design-Checklist-for-Security"><a href="#Design-Checklist-for-Security" class="headerlink" title="Design Checklist for Security"></a>Design Checklist for Security</h3><p><strong>Allocation of Responsibilities</strong>确定哪些系统职责需要确保安全性。对于每个需要安全保障的职责，确保分配了以下附加职责</p><blockquote><p><em>（黑点属于GPT解释内容）</em>：</p></blockquote><ol><li><strong>识别行为主体 (Identify the actor)</strong><ul><li>确保能够识别系统交互中的用户或其他行为主体的身份。</li></ul></li><li><strong>验证行为主体 (Authenticate the actor)</strong><ul><li>确保行为主体是他们声称的身份。</li></ul></li><li><strong>授权行为主体 (Authorize actors)</strong><ul><li>确保已验证身份的行为主体具备访问数据或服务的权限。</li></ul></li><li><strong>授予或拒绝访问数据或服务 (Grant or deny access to data or services)</strong><ul><li>基于权限授予或拒绝对数据或服务的访问。</li></ul></li><li><strong>记录访问或修改数据或服务的尝试 (Record attempts to access or modify data or services)</strong><ul><li>对所有访问和修改数据或服务的尝试进行记录，以供审计和分析。</li></ul></li><li><strong>加密数据 (Encrypt data)</strong><ul><li>对传输或存储的数据进行加密，确保数据的机密性和完整性。</li></ul></li><li><strong>识别资源或服务的可用性下降，并通知相关人员，限制访问 (Recognize reduced availability for resources or services and inform appropriate personnel and restrict access)</strong><ul><li>当资源或服务的可用性下降时，通知相关人员，并适当限制访问以确保系统的稳定性。</li></ul></li><li><strong>从攻击中恢复 (Recover from an attack)</strong><ul><li>提供应急恢复机制，保证系统在攻击后能够恢复正常运行。</li></ul></li><li><strong>验证校验和与哈希值 (Verify checksums and hash values)</strong><ul><li>使用校验和或哈希值验证数据或文件的完整性，检测篡改或损坏。</li></ul></li></ol><p><strong>Coordination Model</strong><br>确定与其他系统或个人进行通信和协调所需的机制。针对这些通信，确保以下机制的存在：</p><ol><li><strong>认证与授权机制</strong>：<br>验证通信中行为主体或系统的身份，并授权其访问权限。</li><li><strong>数据加密机制</strong>：<br>在连接上传输的数据应加密，以确保数据安全性。</li><li><strong>监控与识别机制</strong>：<br>建立监控机制，识别资源或服务中意外的高需求情况。</li><li><strong>限制或终止连接的机制</strong>：<br>提供在检测到异常行为时限制或终止连接的功能。</li></ol><p><strong>Data model</strong></p><p>确定不同数据字段的敏感性。对于每个数据抽象：</p><ol><li><strong>确保不同敏感级别的数据分离存储</strong>。</li><li><strong>确保不同敏感级别的数据具有不同的访问权限</strong>，并在访问之前检查权限。</li><li><strong>确保对敏感数据的访问被记录</strong>，且日志文件受到适当保护。</li><li><strong>确保数据经过适当加密</strong>，并将加密密钥与加密数据分离存放。</li><li><strong>确保当数据被不当修改时能够恢复数据</strong>。</li></ol><p><strong>Mapping Among Architectural Elements</strong>确定架构元素的不同映射方式如何影响个人或系统对数据的读取、写入或修改，对系统服务或资源的访问，或对资源可用性的降低。确定不同映射方式如何影响对数据、服务或资源访问的记录，以及对资源高需求的识别。</p><p>对于每种映射方式，确保分配了以下职责：</p><ol><li><strong>识别访问者（Actor）</strong></li><li><strong>验证访问者身份</strong></li><li><strong>授权访问者</strong></li><li><strong>授予或拒绝访问数据或服务的权限</strong></li><li><strong>记录尝试访问或修改数据或服务的行为</strong></li><li><strong>对数据进行加密</strong></li><li><strong>识别资源或服务可用性降低的情况，通知相关人员并限制访问</strong></li><li><strong>从攻击中恢复</strong></li></ol><p><strong>Resource Management</strong></p><ol><li><strong>确定系统资源的需求</strong><br>确定系统所需的资源，用于识别和监控以下类型的用户或系统：<ul><li>内部或外部用户</li><li>授权或未授权用户</li><li>具有特定资源或全部资源访问权限的用户</li></ul></li><li><strong>确定资源需求</strong><br>确定完成以下任务所需的资源：<ul><li><strong>验证访问者身份</strong></li><li><strong>授予或拒绝访问数据或资源的权限</strong></li><li><strong>通知相关实体</strong></li><li><strong>记录访问数据或资源的尝试</strong></li><li><strong>加密数据</strong></li><li><strong>识别资源的高需求情况</strong></li><li><strong>通知用户或系统</strong></li><li><strong>限制访问</strong></li></ul></li><li><strong>考虑资源的安全性和可用性</strong><ul><li>确定是否有外部实体可以访问或耗尽关键资源。</li><li>确保资源的监控、管理和利用率日志记录机制完善。</li><li>确保有足够的资源来执行必要的安全操作。</li></ul></li><li><strong>防止污染扩散</strong><ul><li>确保受污染的组件不会污染其他组件。</li></ul></li><li><strong>保护共享资源</strong><ul><li>确保共享资源不会被用来将敏感数据从拥有访问权限的用户传递给无访问权限的用户。</li></ul></li></ol><p><strong>Binding Time</strong></p><p><strong>确定可能不受信任的延迟绑定组件实例</strong><br>确定哪些情况下延迟绑定的组件实例可能不可信。<br>确保延迟绑定组件可以被验证：</p><ul><li><strong>验证组件</strong>：确保每个延迟绑定组件都能通过所有权证书来验证其可信度。</li><li><strong>管理访问</strong>：控制这些组件访问数据和服务的权限，必要时阻止不可信组件的访问。</li><li><strong>记录操作</strong>：对于这些组件对系统资源的任何访问、修改和尝试，必须有记录机制。</li><li><strong>加密数据</strong>：敏感数据应加密，并确保延迟绑定组件无法直接访问加密密钥。</li></ul><p><strong>Choice of Technology</strong></p><p><strong>确定可用于用户身份验证、数据访问权限、资源保护和数据加密的技术</strong><br>确定哪些技术可以帮助实现用户身份验证、控制数据访问权限、保护资源和加密数据。</p><p><strong>确保所选技术支持相关的安全策略</strong><br>确保所选的技术能够支持与安全需求相关的策略和战术，确保实现所需的安全措施。</p><h2 id="Chapter-10-Testability"><a href="#Chapter-10-Testability" class="headerlink" title="Chapter 10: Testability"></a>Chapter 10: Testability</h2><p>软件可测试性是指通过（通常基于执行的）测试使软件展示其缺陷的难易程度</p><p>为了使一个系统具有良好的可测试性，必须能够控制每个组件的输入（并可能操纵其内部状态），然后能够观察其输出（以及可能的内部状态）</p><table><thead><tr><th><strong>Portion  of     Scenario</strong></th><th><strong>Possible  Values</strong></th></tr></thead><tbody><tr><td><strong>Source</strong></td><td>Unit  testers,  integration testers, system testers, acceptance testers, end users, either  running tests manually手动测试 or using automated testing tools  自动化测试</td></tr><tr><td><strong>Stimulus</strong></td><td>A  set of tests are executed due to the completion of a coding increment such as  a class,  layer  or service; the completed integration of a subsystem; the complete  implementation of the system;  or the delivery of the system to the customer.</td></tr><tr><td><strong>Environment</strong></td><td>Design  time, development time, compile time, integration time, deployment time, run  time</td></tr><tr><td><strong>Artifacts</strong></td><td>正在被测试的系统部分</td></tr><tr><td><strong>Response</strong></td><td>以下一项或多项操作：执行测试套件并捕获结果；记录导致故障的活动；控制和监视系统的状态。</td></tr><tr><td><strong>Response       Measure</strong></td><td>故障发现的工作量、测试覆盖率、时间消耗、依赖链长度、测试准备时间以及风险控制效果</td></tr></tbody></table><p><strong>路径覆盖率</strong>是软件测试中的一个重要指标，指测试用例覆盖程序中所有可能执行路径的比例。路径覆盖率旨在评估测试用例是否充分探索了代码的执行逻辑，确保所有可能的执行路径都被测试过</p><h3 id="Testability-Tactics"><a href="#Testability-Tactics" class="headerlink" title="Testability Tactics"></a>Testability Tactics</h3><p>goal:测试性策略的目标是使软件开发增量完成后更容易进行测试</p><p>测试性策略分为两类：</p><ol><li>第一类策略涉及为系统增加<strong>可控性</strong>和<strong>可观测性</strong>。</li><li>第二类策略涉及<strong>限制系统设计的复杂性</strong>。</li></ol><h4 id="Control-and-Observe-System-State"><a href="#Control-and-Observe-System-State" class="headerlink" title="Control and Observe System State"></a>Control and Observe System State</h4><p><strong>专用接口</strong>：通过测试工具或正常执行，控制或捕获组件的变量值。</p><p><strong>记录&#x2F;回放</strong>Playback：捕获接口间传递的信息，并将其用于进一步的测试输入。</p><p><strong>本地化状态存储</strong>：为了在测试中将系统、子系统或模块启动到任意状态，最方便的方法是将状态集中存储在一个地方。</p><p><strong>抽象数据源</strong>：抽象接口使得更容易替换测试数据。</p><p><strong>沙盒</strong>：将系统与真实世界隔离，避免对真实系统造成影响</p><p><strong>可执行断言</strong>Executable Assertions：断言通常由人工编写并放置在预定位置，用于指示程序何时及何处进入故障状态。</p><h4 id="Limit-Complexity"><a href="#Limit-Complexity" class="headerlink" title="Limit Complexity"></a>Limit Complexity</h4><p><strong>限制结构复杂性</strong>：避免或解决组件间的循环依赖；隔离并封装对外部环境的依赖；总体上减少组件之间的依赖关系。</p><p><strong>限制非确定性</strong>：识别所有非确定性来源（如不受约束的并行性），并尽可能消除这些非确定性。</p><h3 id="Design-Checklist-for-Testability"><a href="#Design-Checklist-for-Testability" class="headerlink" title="Design Checklist for Testability"></a>Design Checklist for Testability</h3><p><strong>Allocation of Responsibilities</strong><br>确定关键系统职责：识别最为关键的系统职责，这些职责需要进行最全面的测试。</p><p><strong>分配额外系统职责</strong>：确保系统分配了以下额外职责：</p><ul><li>执行测试套件并捕获结果（外部测试或自测）。</li><li>捕获（记录）导致故障的活动或导致非预期（可能是突现）行为的活动，这些行为未必是故障。</li><li>控制和观测与测试相关的系统状态。</li></ul><p><strong>Coordination Model</strong><br>对系统通信和协调机制的要求：</p><ul><li><strong>支持测试执行和结果捕获</strong>，确保测试过程的全面性。</li><li><strong>记录故障活动</strong>，为问题定位和分析提供依据。</li><li><strong>支持状态注入和监控</strong>，增强对通信行为的控制和测试灵活性。</li><li><strong>避免非必要的非确定性</strong>，确保测试的可重复性和可靠性。</li></ul><p><strong>Data Model</strong><br>确定主要数据抽象：确定必须测试的关键数据抽象，以确保系统的正确运行。<br><strong>支持数据捕获</strong>：确保可以捕获这些数据抽象实例的值。<br><strong>支持状态注入</strong>：确保在向系统注入状态时，可以设置这些数据抽象实例的值，从而能够重新创建导致故障的系统状态。<br><strong>全面覆盖数据生命周期操作</strong>，验证数据从创建到销毁的各个环节的正确性和稳定性</p><p><strong>Mapping Among Architectural Elements</strong><br>确定如何测试架构元素的可能映射（特别是进程到处理器、线程到进程、模块到组件的映射），以确保达到预期的测试响应，并识别潜在的竞争条件。<br>确定是否可以测试架构元素的非法映射</p><p><strong>Resource Management</strong><br>确保资源充足：确保有足够的资源可用于执行测试套件并捕获结果。<br><strong>测试环境一致性</strong>：确保测试环境能够代表（或更好地与）系统运行的实际环境相同。<br><strong>系统功能支持</strong>：确保系统提供以下功能：</p><ul><li>测试资源限制。</li><li>捕获详细的资源使用信息，以便在发生故障时进行分析。</li><li>为测试目的向系统注入新的资源限制。</li><li>提供虚拟化资源用于测试。</li></ul><p><strong>Binding Time</strong><br><strong>支持后期绑定测试</strong>：确保在编译时之后绑定的组件可以在后期绑定的上下文中进行测试。<br><strong>记录后期绑定信息</strong>：确保在发生故障时可以捕获后期绑定信息，从而重现导致故障的系统状态。<br><strong>测试绑定范围</strong>：确保可以测试所有可能的绑定选项。</p><p><strong>Choice of Technology</strong><br><strong>技术支持</strong>：确保采用的技术能满足回归测试、故障注入、记录与回放等关键需求。<strong>技术可测试性</strong>：选择的技术应支持系统测试需求，例如支持状态注入和故障场景重现，以保证测试的全面性和准确性</p><h2 id="Chapter-11-Usability"><a href="#Chapter-11-Usability" class="headerlink" title="Chapter 11: Usability"></a>Chapter 11: Usability</h2><p>关注用户完成所需任务的难易程度以及系统提供的用户支持类型</p><p>关注Usability已被证明是提升系统质量（或更准确地说，提升用户对质量的感知）的最经济和最简单的方式之一</p><p>可用性架构支持既包括让用户在某些情况下采取主动，例如取消长时间运行的命令、撤销已完成的命令以及聚合数据和命令。</p><p><strong>可用性</strong>包括以下几个方面：</p><ol><li><strong>学习系统功能</strong>：用户快速掌握系统功能的能力。</li><li><strong>高效使用系统</strong>：用户能够高效完成任务的能力。</li><li><strong>减少错误影响</strong>：尽量降低用户错误对系统或任务的负面影响。</li><li><strong>适应用户需求</strong>：系统能够根据用户的需求进行调整或定制。</li><li><strong>提升信心与满意度</strong>：提高用户对系统的信任感和使用满意度。</li></ol><h3 id="Usability-General-Scenario"><a href="#Usability-General-Scenario" class="headerlink" title="Usability General Scenario"></a>Usability General Scenario</h3><table><thead><tr><th><strong>Portion  of     Scenario</strong></th><th><strong>Possible  Values</strong></th></tr></thead><tbody><tr><td><strong>Source</strong></td><td>End  user, possibly in a specialized role</td></tr><tr><td><strong>Stimulus</strong></td><td>End  user tries to use a system efficiently, learn to use the system, minimize the  impact of errors, adapt the system, or configure the system</td></tr><tr><td><strong>Environment</strong></td><td>Runtime  or configuration time</td></tr><tr><td><strong>Artifacts</strong></td><td>System  or the specific portion of the system with which the user is interacting.</td></tr><tr><td><strong>Response</strong></td><td>The  system should either provide the user with the features needed or anticipate预见  the user’s needs.</td></tr><tr><td><strong>Response  Measure</strong></td><td>One  or more of the following: task time, number of errors, number of tasks  accomplished, user satisfaction, gain of user knowledge, ratio of successful  operations to total operations, or amount of time or data lost when an error  occurs.</td></tr></tbody></table><h3 id="Usability-Tactics"><a href="#Usability-Tactics" class="headerlink" title="Usability Tactics"></a>Usability Tactics</h3><p><strong>Support User Initiative</strong>用户主动性<br><strong>取消</strong>：系统必须监听取消请求；被取消的命令必须终止；释放已占用的资源；通知协作组件。<br><strong>暂停&#x2F;恢复</strong>：暂时释放资源，以便将其重新分配给其他任务。<br><strong>撤销</strong>：维护足够的系统状态信息，以便在用户请求时恢复到之前的状态。<br><strong>聚合</strong>：支持将低级对象聚合为一个组，以便用户可以对该组执行操作，从而减轻繁琐的工作。</p><p><strong>Support System Initiative</strong><br><strong>维护任务模型</strong>：确定上下文，以便系统能够理解用户正在尝试执行的操作并提供帮助。<br>维护用户模型**：明确表示用户对系统的知识、用户行为（例如预期的响应时间）等。**<br>维护系统模型**：系统维护其自身的明确模型，用于确定预期的系统行为，以便为用户提供适当的反馈</p><h3 id="Design-Checklist-for-Usability"><a href="#Design-Checklist-for-Usability" class="headerlink" title="Design Checklist for Usability"></a>Design Checklist for Usability</h3><p><strong>Allocation of Responsibilities</strong><br>确保根据需要分配额外的系统职责，以帮助用户：</p><ol><li><em>学习如何高效使用系统。</em></li><li><em>高效地完成当前任务。</em></li><li><em>适应和配置系统。</em></li><li><em>从用户和系统错误中恢复。</em></li></ol><p><strong>Coordination Model</strong><br>确定系统元素协调的属性——时效性、有效性、完整性、正确性、一致性<strong>timeliness, currency, completeness, correctness, consistency</strong>——是否会影响<em>用户如何学习使用系统、实现目标或完成任务、适应和配置系统、从用户和系统错误中恢复、增加信心和满意度。</em></p><p><strong>Data Model</strong><br>确定与用户可感知行为相关的主要数据抽象。<br>确保这些主要数据抽象及其操作和属性的设计有助于用户<em>实现当前任务、适应和配置系统、从用户和系统错误中恢复、学习如何使用系统，并提高满意度和用户信心。</em></p><p><strong>Mapping Among Architectural Elements</strong><br>确定哪些架构元素之间的映射是用户可见的（例如，用户意识到哪些服务是本地的，哪些是远程的）。<br>对于那些可见的映射，确定它们如何影响<em>用户学习如何使用系统、实现任务、适应和配置系统、从用户和系统错误中恢复，以及提高信心和满意度的方式和难易程度。</em></p><p><strong>Resource Management</strong><br>确定用户如何适应和配置系统的资源使用。<br>确保在所有用户控制的配置下，资源限制不会使用户难以完成任务。例如，避免导致过长响应时间的配置。<br>确保资源水平不会影响用户学习如何使用系统的能力，也不会降低他们对系统的信心和满意度。</p><p><strong>Binding Time</strong><br>确定哪些绑定时机决策应由用户控制，并确保用户能够做出有助于可用性的决策。<br>例如，如果用户可以在运行时选择系统的配置、通信协议或通过插件选择功能，您需要确保这些选择<em>不会对用户学习系统功能、有效使用系统、最小化错误影响、进一步适应和配置系统或提高信心和满意度产生不利影响。</em></p><p><strong>Choice of Technology</strong><br>所选择的技术应支持系统的可用性需求，包括提供帮助文档、培训材料和收集用户反馈等功能。此外，所选技术应提升而非降低系统的可用性，确保它们不会妨碍用户学习、操作效率、错误恢复或系统适应，从而增强用户信心和满意度。</p><h2 id="Chapter-12-Other-Quality-Attributes"><a href="#Chapter-12-Other-Quality-Attributes" class="headerlink" title="Chapter 12: Other Quality Attributes"></a>Chapter 12: Other Quality Attributes</h2><p>其它重要质量属性：<br><strong>Variability可变性</strong>：是一种特殊形式的可修改性。它指的是系统及其支持性工件能够支持按预定方式生成一组彼此不同的变体的能力。</p><p><strong>Portability可移植性</strong>：也是一种特殊形式的可修改性。可移植性指的是软件从一个平台迁移到另一个平台时的难易程度。</p><p><strong>Development Distributability 开发可分发性</strong>：是设计软件以支持分布式软件开发的质量。</p><p><strong>Scalability可扩展性</strong>：</p><ul><li><strong>横向扩展</strong>（扩展外部）Horizontal scalability (scaling out)指的是向逻辑单元中添加更多资源，例如向集群中添加另一台服务器。</li><li><strong>纵向扩展</strong>（扩展内部）Vertical scalability (scaling up)指的是向物理单元中添加更多资源，例如为计算机增加更多内存。</li></ul><p><strong>Deployability可部署性</strong>：关注可执行文件如何到达主机平台以及如何被调用。</p><p><strong>Mobility移动性</strong>：涉及平台的移动性问题及其使用特性（例如尺寸、显示类型、输入设备类型、带宽的可用性和容量、电池寿命等）。</p><p><strong>Monitorability可监控性</strong>：涉及操作人员在系统执行过程中监控系统的能力。</p><p><strong>Safety安全性</strong>：软件安全指的是软件避免进入会导致损害、伤害或生命丧失的状态的能力，并在进入不良状态时能够恢复并限制损害。与安全性相关的架构关注几乎与可用性相同（即防止、检测和从故障中恢复）。</p><h3 id="Dealing-with-“X-ability”"><a href="#Dealing-with-“X-ability”" class="headerlink" title="Dealing with “X-ability”"></a>Dealing with “X-ability”</h3><p>假设您必须处理一个没有现成知识体系的质量属性，例如绿色计算。<br>该怎么办？</p><ol><li><strong>建模该质量属性</strong></li><li><strong>为该质量属性组建一套策略</strong></li><li><strong>构建设计检查表</strong></li></ol><p>“X-ability”通常指的是与系统或软件相关的各种能力或质量属性，例如<strong>可扩展性</strong>（scalability）、<strong>可维护性</strong>（maintainability）、<strong>可用性</strong>（usability）等。这类能力通常强调系统在面对特定挑战时的表现和适应能力。</p><p>处理“X-ability”问题时，通常涉及以下几个步骤：</p><ol><li><strong>定义目标</strong>：明确X-ability的具体含义和目标。</li><li><strong>建模和分析</strong>：通过建模来了解如何量化和评估该能力。</li><li><strong>制定策略</strong>：为实现该能力制定一系列设计和实现策略。</li><li><strong>监控和优化</strong>：持续监控系统的表现，进行优化和改进，确保达到预期的“X-ability”。</li></ol><h2 id="Chapter-13-Patterns-and-Tactics"><a href="#Chapter-13-Patterns-and-Tactics" class="headerlink" title="Chapter 13: Patterns and Tactics"></a>Chapter 13: Patterns and Tactics</h2><p>pattern：架构模式定义了如何通过抽象的解决方案来解决特定上下文中的问题。解决方案包括对组件类型、组件间交互机制、组件布局和约束条件的定义，帮助架构师在重复出现的情境中选择和应用合适的解决方案。</p><h4 id="Layer-Pattern"><a href="#Layer-Pattern" class="headerlink" title="Layer Pattern"></a>Layer Pattern</h4><p><strong>Layer Pattern</strong>：<strong>分层模式</strong>通过将软件分为不同的层来实现关注点的分离。每个层包含一个模块集合，提供特定的服务，并且层与层之间的交互是单向的。这种模式使得软件模块可以独立开发和维护，同时支持可移植性、可修改性和重用性</p><p><strong>概述</strong>：分层模式定义了层（即提供一组内聚服务的模块集合）以及层之间的单向使用关系。<br><strong>元素</strong>：</p><ul><li><strong>层</strong>：一种模块。每个层的描述应定义该层包含哪些模块。</li></ul><p><strong>关系</strong>：</p><ul><li><strong>允许使用</strong>：设计应定义每层的使用规则及任何允许的例外情况。</li></ul><p><strong>约束</strong>：</p><ul><li>每个软件单元只能分配给一个层。</li><li>至少有两个层（通常有三个或更多）。</li><li>允许使用关系不应是循环的（即较低层不能使用上层）。</li></ul><p><strong>弱点</strong>：</p><ul><li>添加层会增加系统的初期成本和复杂性。</li><li>层会带来性能损失</li></ul><h4 id="Broker-Pattern"><a href="#Broker-Pattern" class="headerlink" title="Broker Pattern"></a><strong>Broker Pattern</strong></h4><p><strong>Broker Pattern</strong>：<strong>代理模式</strong>通过引入一个代理中介，将客户端与服务器服务提供者解耦，从而使得客户端无需了解服务提供者的细节。代理模式不仅简化了服务绑定的管理，还使得服务的动态切换变得更加容易。</p><p>Broker Solution – 1<br><strong>概述</strong>：代理模式定义了一个运行时组件，称为<strong>代理</strong>，它在多个客户端和服务器之间调解通信。<br><strong>元素</strong>：</p><ul><li><strong>客户端</strong>：服务的请求者。</li><li><strong>服务器</strong>：服务的提供者。</li><li><strong>代理</strong>：一个中介，负责定位合适的服务器来满足客户端的请求，将请求转发给服务器，并将结果返回给客户端。</li><li><strong>客户端代理</strong>：一个中介，管理与代理的实际通信，包括消息的编组、发送和解组。</li><li><strong>服务器端代理</strong>：一个中介，管理与代理的实际通信，包括消息的编组、发送和解组。</li></ul><p>Broker Solution - 2<br><strong>关系</strong>：附加关系将客户端（以及可选的客户端代理）和服务器（以及可选的服务器端代理）与代理关联起来。<br><strong>约束</strong>：</p><ul><li>客户端只能附加到代理（可能通过客户端代理）。</li><li>服务器只能附加到代理（可能通过服务器端代理）。</li></ul><p><strong>弱点</strong>：</p><ul><li>代理在客户端和服务器之间增加了一层间接性，从而增加了延迟，并且这一层可能成为通信瓶颈。</li><li>代理可能成为单点故障。</li><li>代理增加了前期复杂性。</li><li>代理可能成为安全攻击的目标。</li><li>代理可能难以测试。</li></ul><h4 id="Model-View-Controller-Pattern"><a href="#Model-View-Controller-Pattern" class="headerlink" title="Model-View-Controller Pattern"></a>Model-View-Controller Pattern</h4><p>context：将用户界面于应用程序功能分离，同时仍能响应用户输入或底层应用程序数据的变化</p><p>模型-视图-控制器（MVC）模式将应用程序功能分为三种组件：</p><ul><li>模型：包含应用程序的数据。</li><li>视图：显示底层数据的某部分并与用户交互。</li><li>控制器：在模型和视图之间调解，管理状态变化的通知。</li></ul><p>关系：notifies 关系连接模型、视图和控制器的实例，通知相关状态的变化。</p><p><strong>约束</strong>：</p><ul><li>必须至少有一个模型、视图和控制器的实例。</li><li>模型组件不应直接与控制器交互。</li></ul><p>弱点：<br>对于简单的用户界面，MVC的复杂性可能不值得采用。<br>对于某些用户界面工具包，模型、视图和控制器的抽象可能不适用。</p><h4 id="Pipe-and-Filter-Pattern"><a href="#Pipe-and-Filter-Pattern" class="headerlink" title="Pipe and Filter Pattern"></a>Pipe and Filter Pattern</h4><p>context:许多系统需要将离散数据项的流从输入转换到输出。许多类型的转换在实践中反复发生，因此将这些转换创建为独立、可重用的部分是可取的。</p><p>管道-过滤器模式中的交互模式是通过连续的转换对数据流进行处理。数据通过过滤器的输入端口进入，经过转换后，通过输出端口通过管道传递给下一个过滤器。单个过滤器可以从一个或多个端口获取数据，或将数据传递给一个或多个端口</p><p><strong>元素</strong>：</p><ul><li><strong>过滤器</strong>：组件，用于将输入端口读取的数据转换为输出端口写出的数据。</li><li><strong>管道</strong>：连接器，用于将数据从过滤器的输出端口传输到另一个过滤器的输入端口。管道只有一个输入源和一个输出目标，能够保持数据项的顺序，并且不会改变通过的数据。</li></ul><p>关系：attachment relation将过滤器的输出与管道的输入端口以及管道的输出端口与过滤器的输入端口相关联。</p><p>约束：</p><ul><li>管道将过滤器的输出端口连接到过滤器的输入端口。</li><li>连接的过滤器必须一致地约定传递的数据类型。</li></ul><h4 id="Client-Server-Pattern"><a href="#Client-Server-Pattern" class="headerlink" title="Client-Server Pattern"></a>Client-Server Pattern</h4><p>背景：存在共享资源和服务，大量分布式客户端希望访问这些资源和服务，我们需要控制其访问权限或服务质量。</p><p>客户端通过请求服务器提供的服务进行交互。某些组件可能同时充当客户端和服务器。可以有一个中心服务器或多个分布式服务器。</p><p>概述：客户端发起与服务器的交互，根据需要调用服务器的服务，并等待这些请求的结果。</p><p>元素：</p><ul><li>客户端：一个调用服务器服务的组件。客户端有端口，描述它们所需要的服务。</li><li>服务器：提供服务给客户端的组件。服务器有端口，描述它们所提供的服务。</li></ul><p>请求&#x2F;回复连接器：采用请求&#x2F;回复协议的数据连接器，客户端通过它调用服务器的服务。重要特性包括调用是本地还是远程，数据是否加密等。</p><p>Relations: The attachment relation associates clients with servers.</p><p><strong>约束</strong>：</p><ul><li>客户端通过请求&#x2F;回复连接器与服务器连接。</li><li>服务器组件可以是其他服务器的客户端。</li></ul><p>弱点：</p><p>服务器可能成为性能瓶颈。<br>服务器可能成为单点故障。<br>关于将功能放置在客户端还是服务器上的决策，通常复杂且在系统构建后更改成本高。</p><h4 id="Peer-to-Peer-Pattern"><a href="#Peer-to-Peer-Pattern" class="headerlink" title="Peer-to-Peer Pattern"></a>Peer-to-Peer Pattern</h4><p><strong>背景</strong>：<br>分布式计算实体——每个实体在启动交互方面都是平等的，并且提供自己的资源——需要合作和协作，以便为分布式用户社区提供服务。</p><p>在对等（P2P）模式中，组件直接作为对等方进行交互。所有对等方都是“平等”的，没有任何一个对等方或一组对等方对系统的健康至关重要。对等通信通常是request&#x2F;reply交互，与客户端-服务器模式中的不对称性不同。</p><p>元素：</p><ul><li>对等方（Peer）：独立的组件，运行在网络节点上。特殊的对等方组件可以提供路由、索引和对等方搜索能力。</li><li>请求&#x2F;回复连接器（Request&#x2F;Reply Connector）：用于连接到对等网络，搜索其他对等方，并从其他对等方调用服务。在某些情况下，可能不需要回复。</li></ul><p><strong>关系</strong>：<br>此关系将对等方与其连接器关联起来。Attachments在运行时可能会发生变化。</p><p>约束： 可以对以下内容进行限制：</p><ul><li>任何给定对等方的可连接数量</li><li>搜索对等方时的跳数</li><li>哪些对等方知道其他对等方</li><li>一些P2P网络采用星形拓扑结构，其中对等方只连接到超级节点（supernodes）</li></ul><p>弱点：</p><p>安全性、数据一致性、数据&#x2F;服务可用性、备份和恢复的管理更为复杂。<br>小型P2P系统可能无法始终如一地实现性能和可用性等质量目标。</p><h4 id="Service-Oriented-Architecture-Pattern（SOA）"><a href="#Service-Oriented-Architecture-Pattern（SOA）" class="headerlink" title="Service Oriented Architecture Pattern（SOA）"></a>Service Oriented Architecture Pattern（SOA）</h4><p>面向服务架构模式</p><p>背景：许多服务由服务提供者提供并描述，服务消费者需要能够理解并使用这些服务，而无需详细了解它们的实现。</p><p>面向服务架构（SOA）模式描述了一组提供and&#x2F;or 消费服务的分布式组件</p><p>概述：计算是通过一组协作的组件实现的，这些组件通过网络提供 and&#x2F;or消费服务。</p><p>元素：<br>服务提供者：通过发布接口提供一个或多个服务。<br>服务消费者：直接或通过中介调用服务。<br>服务提供者也可以是服务消费者。<br>企业服务总线（ESB）：一个中介元素，能够在服务提供者和消费者之间路由和转换消息。<br>服务注册表：服务提供者用于注册服务，服务消费者用于在运行时发现服务。<br>编排服务器：根据业务流程和工作流的语言，协调服务消费者和提供者之间的交互。</p><p>连接器：<br>SOAP 连接器：使用 SOAP 协议进行 Web 服务之间的同步通信，通常通过 HTTP 实现。<br>REST 连接器：依赖于 HTTP 协议的基本请求&#x2F;响应操作，进行 Web 服务之间的通信。<br>异步消息传递连接器Asynchronous messaging connector：使用消息传递系统提供点对点或发布&#x2F;订阅的异步消息交换。</p><p>关系：<br>各种组件通过相应的连接器进行连接。</p><p>约束：<br>服务消费者与服务提供者之间需要建立连接，但可以使用中介组件（例如 ESB、注册表、编排服务器）进行通信。</p><p>弱点：<br>基于 SOA 的系统通常构建起来较为复杂。<br>无法控制独立服务的演变。<br>中间件会引入性能开销，服务可能成为性能瓶颈，并且通常不提供性能保证。</p><h4 id="Publish-Subscribe-Pattern"><a href="#Publish-Subscribe-Pattern" class="headerlink" title="Publish-Subscribe Pattern"></a>Publish-Subscribe Pattern</h4><p>创建支持数据生产者和消费者之间传输消息的集成机制，使得他们对彼此的身份甚至是存在都无需了解</p><p>在发布-订阅模式中，组件通过宣布消息或事件进行交互。组件可以订阅一组事件。发布者组件通过事件总线发布事件；连接器则将这些事件传递给已注册感兴趣的订阅者组件。</p><p>概述： 组件发布和订阅事件。当组件宣布一个事件时，连接器基础设施会将事件传递给所有已注册的订阅者。</p><p>元素：</p><ul><li>任何具有至少一个发布或订阅端口的组件。</li><li>发布-订阅连接器，具有宣布和监听角色，供希望发布和订阅事件的组件使用。</li></ul><p>关系： 附件关系将组件与发布-订阅连接器关联，规定哪些组件宣布事件，哪些组件注册以接收事件。</p><p>约束： 所有组件都连接到一个事件分发器，该分发器可以视为总线连接器或组件。发布端口连接到宣布角色，订阅端口连接到监听角色。</p><p>弱点：</p><p>通常会增加延迟，并对消息传递时间的可预测性和可扩展性产生负面影响。<br>对消息的顺序控制较少，且消息的传递不被保证。</p><h4 id="Shared-Data-Pattern"><a href="#Shared-Data-Pattern" class="headerlink" title="Shared-Data Pattern"></a>Shared-Data Pattern</h4><p><strong>上下文</strong>：各种计算组件需要共享和操作大量数据。这些数据不完全属于任何一个组件。如何存储和操作由多个独立组件访问的持久化数据？</p><p>在共享数据模式中，交互主要通过多个数据访问者和至少一个共享数据存储（data store）之间的数据交换来主导。数据交换可以由数据访问者或数据存储（data store）发起。连接器的类型是数据的读写。</p><p>概述：数据访问者之间的通信通过共享数据存储（data store）进行调解。控制可以由数据访问者或数据存储（data store）发起。数据由数据存储（data store）进行持久化。</p><p>元素：</p><ul><li>共享数据存储（data store）：包括存储的数据类型、数据性能相关属性、数据分布以及允许的访问者数量等方面的考虑。</li><li>数据访问组件。</li><li>数据读写连接器。</li></ul><p>关系：附件关系决定了哪些数据访问者连接到哪些数据存储（data store）。</p><p>约束：数据访问者只能与数据存储（data store）进行交互。</p><p>弱点：</p><p>共享数据存储可能成为性能瓶颈。<br>共享数据存储可能成为单点故障。<br>数据的生产者和消费者可能紧密耦合。</p><h4 id="Map-Reduce-Pattern"><a href="#Map-Reduce-Pattern" class="headerlink" title="Map-Reduce Pattern"></a>Map-Reduce Pattern</h4><p>上下文：企业迫切需要快速分析它们生成或访问的庞大数据集，数据规模达到PB级别。1拍字节（PB）等于1024太字节（TB）</p><p>对于许多处理超大数据集的应用程序，排序数据并对分组数据进行分析就足够了。Map-Reduce模式解决的问题是如何高效地对大数据集进行分布式并行排序，并为程序员提供简单的方式来指定要进行的分析。</p><p>Map-Reduce模式需要三个部分：</p><p>专用基础设施，负责在大规模并行计算环境中将软件分配到硬件节点，并根据需要处理数据排序。<br>一个由程序员指定的组件“map”，用于过滤数据并检索retrieve要进行合并的项。<br>一个由程序员指定的组件“reduce”，用于合并“map”组件的结果。</p><p><strong>元素</strong>：</p><ol><li><strong>Map</strong>：是一个函数，在多个处理器上部署多个实例，执行分析中的提取和转换部分。</li><li><strong>Reduce</strong>：是一个函数，可能作为单个实例或多个实例在处理器上部署，执行提取-转换-加载（ETL）过程中的加载部分。</li><li><strong>基础设施</strong>：是负责部署Map和Reduce实例的框架，管理数据在它们之间的传输，并能够检测和恢复故障。</li></ol><p>关系：<br>Deploy on：表示Map或Reduce函数的实例与其部署的处理器之间的关系。<br>Instantiate, monitor, and control：表示基础设施与Map和Reduce实例之间的关系，涉及实例的创建、监控和控制。</p><p>约束：<br>要分析的数据必须以文件集的形式存在。<br>Map函数是无状态的，并且彼此之间不进行通信。<br>Map和Reduce实例之间唯一的通信方式是通过Map实例发出的&lt;key, value&gt;对数据。</p><p>弱点：<br>如果没有大数据集，使用Map-Reduce的开销就不值得。<br>如果无法将数据集划分为大小相似的子集，平行处理的优势就会丧失。<br>需要多个Reduce的操作难以协调和执行。</p><h4 id="Multi-Tier-Pattern"><a href="#Multi-Tier-Pattern" class="headerlink" title="Multi-Tier Pattern"></a>Multi-Tier Pattern</h4><p>将系统拆分成多个计算上独立的执行结构—一组组由软件和硬件组成的群体，通过某种通信媒介相互连接</p><p>许多系统的执行结构被组织成一组逻辑上的组件分组。每个分组被称为层（tier）。</p><p>概述： 许多系统的执行结构被组织为一组逻辑上的组件分组。每个分组称为层（tier）。</p><p><strong>元素</strong>：<strong>层（Tier）</strong>：是软件组件的逻辑分组。</p><p>关系：</p><p>Is part of：将组件分组为层。<br>Communicates with：显示各个层及其内部组件如何相互作用。<br>Allocated to：当层映射到计算平台时，表示层分配给特定平台。</p><p>约束：<br>每个软件组件只能属于一个层。</p><p>弱点：<br>需要大量的前期成本和复杂度。</p><h4 id="模式与战术的关系"><a href="#模式与战术的关系" class="headerlink" title="模式与战术的关系"></a>模式与战术的关系</h4><p>模式是由战术构建的，战术是原子，模式是分子。</p><h4 id="Tactics-Augment-Patterns"><a href="#Tactics-Augment-Patterns" class="headerlink" title="Tactics Augment Patterns"></a>Tactics Augment Patterns</h4><p>模式解决特定问题，但在其他特性方面可能是中立的，或存在弱点。</p><p>以Broker模式为例：</p><p>性能瓶颈：Broker作为中介可能导致通信延迟或处理能力不足。<br>单点故障：如果Broker崩溃，整个系统的通信可能会中断，导致系统的可用性降低。</p><p>为了应对这些弱点，可以使用以下策略（Tactics）：<br>增加资源（Increase resources）<br>维护多个副本（Maintain multiple copies）</p><p>优点（Pluses）缺点（Minuses）</p><h2 id="chapt14Quality-Attribute-Modeling-and-Analysis？？"><a href="#chapt14Quality-Attribute-Modeling-and-Analysis？？" class="headerlink" title="chapt14Quality Attribute Modeling and Analysis？？"></a>chapt14Quality Attribute Modeling and Analysis？？</h2><p>强调了在软件架构设计中，如何通过建模、分析和实验来评估和优化系统的质量属性。</p><p><strong>Performance Models</strong></p><p>•Parameters: arrival rate of events, chosen queuing discipline, chosen scheduling algorithm, service time for events, network topology, network bandwidth, routing algorithm chosen</p><p><strong>Queuing Model for MVC</strong></p><p>1.Arrivals</p><p>2.View sends requests to Controller</p><p>3.Actions returned to View</p><p>4.Actions returned to model</p><p>5.Model sends actions to View</p><p><strong>Maturity of Quality Attribute Models</strong></p><table><thead><tr><th><strong>Quality Attribute</strong></th><th><strong>Intellectual Basis</strong></th><th><strong>Maturity &#x2F; Gaps</strong></th></tr></thead><tbody><tr><td><strong>Availability</strong></td><td>Markov  models; Statistical models</td><td>Moderate  maturity  in the  hardware reliability domain, less mature in the software domain. Requires  models that speak to state recovery and for which failure percentages can be  attributed to software.</td></tr><tr><td><strong>Interoperability</strong></td><td>Conceptual  framework</td><td>Low  maturity; models require substantial human interpretation and input.</td></tr><tr><td><strong>Modifiability</strong></td><td>Coupling  and cohesion metrics; Cost models</td><td>Substantial  research in academia; still requires more empirical support in real-world  environments.</td></tr><tr><td><strong>Performance</strong></td><td>Queuing  theory; Real time scheduling theory</td><td>High  maturity; requires considerable education and training to use properly.</td></tr><tr><td><strong>Security</strong></td><td>No  architectural models</td><td></td></tr><tr><td><strong>Testability</strong></td><td>Component  Interaction Metrics</td><td>Low  maturity;  little empirical validation.</td></tr><tr><td><strong>Usability</strong></td><td>No  architectural models</td><td></td></tr></tbody></table><p>分析始终是一个成本&#x2F;收益的活动</p><ul><li><p><strong>成本</strong>：是指创建和执行分析模型和工具的开销。</p></li><li><p>收益</p><p>：取决于以下几个因素：</p><ul><li>分析的准确性Accuracy of analysis</li><li>分析对象的重要性</li></ul></li></ul><p>分析可以通过以下方式进行：</p><ul><li>针对某些属性的模型–Models for some attributes</li><li>测量</li><li>思维实验–Thought experiments（通过思维实验探索设计替代方案和评估设计选择。）</li><li>模拟–Simulations</li><li>原型–Prototypes</li></ul><h2 id="Chapter-15-Architectures-in-Agile-Projects？？"><a href="#Chapter-15-Architectures-in-Agile-Projects？？" class="headerlink" title="Chapter 15: Architectures in Agile Projects？？"></a>Chapter 15: Architectures in Agile Projects？？</h2><ol><li><strong>敏捷性（Agility）</strong>：<ul><li>敏捷流程是为了使项目更能响应利益相关者的需求、更快地开发用户关心的功能、更早地展示项目进展，并减少因文档化不可避免变化的项目方面而产生的负担。</li><li>敏捷和架构不是相互排斥的，而是许多软件项目的愉快伴侣。</li></ul></li><li><strong>敏捷宣言（Agile Manifesto）</strong>：<ul><li>敏捷宣言强调个体和互动、可工作的软件、客户合作和响应变化的重要性。</li></ul></li><li><strong>敏捷原则（Twelve Agile Principles）</strong>：<ul><li>包括优先满足客户通过持续交付有价值的软件、欢迎变更、频繁交付可工作的软件、业务人员和开发者必须每日合作等原则。</li></ul></li><li><strong>敏捷实践</strong>：<ul><li>最初在中小规模、时间框架短的项目中使用，并且取得了相当的成功。在大型项目或分布式开发中不常使用。</li></ul></li><li><strong>架构工作量（How Much Architecture?）</strong>：<ul><li>项目中有两个活动会增加项目时间：前期架构设计工作和前期风险识别、规划和解决工作。</li><li>这些活动与返工（由于修复缺陷和处理修改请求）之间存在权衡。</li></ul></li><li><strong>敏捷与文档化（Agility and Documentation）</strong>：<ul><li>为读者而写，如果读者不需要，就不要写。但要记住，读者可能是尚未参与项目的维护者或其他新人。</li></ul></li><li><strong>敏捷与架构评估（Agility and Architecture Evaluation）</strong>：<ul><li>架构评估可以作为敏捷流程的一部分。敏捷哲学的核心是满足利益相关者的重要关注点。</li></ul></li><li><strong>敏捷架构示例（An Example of Agile Architecting）</strong>：<ul><li>WebArrow Web-conferencing系统展示了架构师和开发者需要同时以两种不同的模式思考和工作：自顶向下设计和分析架构结构，以及自底向上分析特定于实现和环境的约束。</li></ul></li><li><strong>实验以做出权衡（Experiments to Make Tradeoffs）</strong>：<ul><li>团队采用敏捷架构纪律和严格的实验计划来分析架构权衡，这些实验在敏捷术语中被称为“spiky”。</li></ul></li><li><strong>敏捷架构师的指导方针（Guidelines for the Agile Architect）</strong>：<ul><li>巴里·博姆（Barry Boehm）及其同事开发了增量承诺模型，将敏捷性和架构结合起来。</li></ul></li><li><strong>建议（Our Advice）</strong>：<ul><li>对于大型、复杂系统，前期进行大量的架构工作是值得的。对于要求不稳定的大型项目，快速设计候选架构。对于小型项目，至少尝试就主要模式达成一致，不要在前期花费太多时间在架构设计、文档化或分析上。</li></ul></li><li><strong>总结（Summary）</strong>：<ul><li>敏捷宣言和原则强调紧密合作的团队，以及持续、频繁地交付可工作的软件。</li><li>大型成功项目需要敏捷和架构的结合。</li><li>敏捷架构师采取中间立场，提出初始架构，并在此基础上运行，直到技术债务变得过大，需要重构。</li></ul></li></ol><h2 id="Chapter-16-Architecture-and-Requirements"><a href="#Chapter-16-Architecture-and-Requirements" class="headerlink" title="Chapter 16:  Architecture and Requirements"></a>Chapter 16:  Architecture and Requirements</h2><p>ASR: architecturally significant requirement*</p><p>架构的目的是构建满足需求的系统。对架构师而言，并非所有需求都同等重要。架构上显著的需求（ASR）会对架构产生深远影响。</p><h3 id="从需求文档收集ASR"><a href="#从需求文档收集ASR" class="headerlink" title="从需求文档收集ASR"></a>从需求文档收集ASR</h3><p>需求文档或用户故事是寻找潜在ASR的明显来源，但许多项目并未创建或维护详细的高质量需求文档</p><h3 id="从利益相关者处收集ASR："><a href="#从利益相关者处收集ASR：" class="headerlink" title="从利益相关者处收集ASR："></a><strong>从利益相关者处收集ASR</strong>：</h3><ul><li>利益相关者通常不清楚他们想要的系统质量属性（QA）。通过访谈相关利益相关者，可以了解他们的需求和知识。</li><li>利益相关者访谈的结果应包括 架构驱动因素列表 ;利益相关者（作为一个组）优先考虑的一组 QA 场景。</li></ul><h3 id="QAW-Quality-Attribute-Workshop质量属性研讨会"><a href="#QAW-Quality-Attribute-Workshop质量属性研讨会" class="headerlink" title="QAW: Quality Attribute Workshop质量属性研讨会"></a>QAW: Quality Attribute Workshop<strong>质量属性研讨会</strong></h3><p>QAW 是一种以利益相关者为中心的便利<strong>方法</strong>，用于在软件架构完成之前生成、优先考虑和优化质量属性场景。 QAW 侧重于系统级问题，特别是软件将在系统中扮演的角色。</p><h3 id="从商业目标中提取ASR："><a href="#从商业目标中提取ASR：" class="headerlink" title="从商业目标中提取ASR："></a><strong>从商业目标中提取ASR</strong>：</h3><ul><li>商业目标可以以结构化的形式表达，并表示为场景。PALM是一种用于提取商业目标的结构化引导方法。</li></ul><p>Business goal scenario, 7 parts:•<em>Goal</em>*-<strong>source*;•*Goal</strong>-<strong>subject* ;•*Goal</strong>-*<em>object</em>;•<em>Environment</em>;•<em>Goal</em>;•<em>Goal-measure</em>;•<em>Pedigree and value</em></p><p>PALM（Prioritizing Architecturally Significant Requirements）:一个用于识别和记录商业目标的结构化方法</p><h3 id="PALM方法概述："><a href="#PALM方法概述：" class="headerlink" title="PALM方法概述："></a><strong>PALM方法概述</strong>：</h3><ul><li>PALM是一个七步方法，通常在一个半日的工作坊中进行。</li><li>参与者包括架构师和能够讨论相关商业目标的利益相关者。</li></ul><p><strong>步骤</strong>：</p><ul><li><strong>PALM概述介绍</strong>：介绍PALM方法、它解决的问题、步骤和预期结果。</li><li><strong>商业驱动因素<em>drivers</em>介绍</strong>：项目管理简要介绍客户组织和开发组织的目标。</li><li><strong>架构驱动因素介绍</strong>：架构师简要介绍驱动商业和质量属性需求的业务目标和质量属性需求（ASRs）。</li><li><strong>商业目标识别</strong>：详细阐述商业目标并将其表达为场景。合并几乎相同的商业目标以消除重复。参与者对结果集进行优先排序，以识别最重要的目标。</li><li><strong>从商业目标中识别潜在的质量属性</strong>：对于每个重要的商业目标场景，参与者描述一个质量属性，如果将其设计到系统中，将有助于实现该目标。如果质量属性还不是需求，则记录为发现。</li><li><strong>为现有质量属性驱动因素分配血统</strong>Assignment of pedigree：对于每个架构驱动因素，确定其支持的商业目标。如果没有，则记录为发现。否则，通过询问定量部分的来源来确定其血统。</li><li><strong>练习结束</strong>：回顾结果、下一步和参与者反馈。</li></ul><h3 id="Capturing-ASRs-in-a-Utility-Tree"><a href="#Capturing-ASRs-in-a-Utility-Tree" class="headerlink" title="Capturing ASRs in a Utility Tree"></a><strong>Capturing ASRs in a Utility Tree</strong></h3><ul><li>效用树是一种记录ASR的方法，它根据对架构的影响和商业或任务价值来确定每个ASR的优先级。</li><li>步骤如下：<ul><li><strong>定义效用树的结构</strong>：<ul><li>效用树的根节点是一个占位符节点，称为“效用”。</li><li>第二层包含广泛的质量属性类别。</li><li>第三层进一步细化这些类别。</li></ul></li><li><strong>捕获ASR作为场景</strong>：<ul><li>每个ASR应该以场景的形式被捕获。场景通常包括源、刺激、工件、环境、响应和响应度量。</li></ul></li><li><strong>确定ASR的优先级</strong>：<ul><li>根据ASR对架构的影响和商业或任务价值来确定每个ASR的优先级。</li><li>优先级可以使用高（H）、中（M）、低（L）等标签来表示。</li></ul></li><li><strong>分析和调整</strong>：<ul><li>如果某个质量属性或其细化没有ASR，则不一定是错误或遗漏，但应关注在该领域寻找未记录的ASR。</li><li>评级为（H,H）的ASR应受到最多关注。</li><li>如果有大量这样的ASR，可能会引起关注：系统是否可实现？</li></ul></li><li><strong>利益相关者审查</strong>：<ul><li>利益相关者可以审查效用树，以确保他们的关注点得到解决。</li></ul></li><li><strong>下一步行动</strong>：<ul><li>使用效用树来指导架构设计的优先级和顺序。</li><li>效用树可以帮助架构师确定哪些ASR需要首先解决。</li></ul></li></ul></li></ul><h3 id="方法的整合："><a href="#方法的整合：" class="headerlink" title="方法的整合："></a><strong>方法的整合</strong>：</h3><ul><li>如何结合使用需求文档、利益相关者访谈、质量属性研讨会、PALM和效用树。如果现有的需求过程能够收集、识别和优先排序ASR，则使用该过程。</li><li>如果没有人捕捉到您正在构建的系统背后的业务目标，请使用 PALM。 如果在需求收集过程中忽略了重要的利益相关者，请使用访谈或 QAW。</li></ul><p>summary：架构由对架构有深远影响的架构上显著需求驱动。这些需求可以通过需求文档、利益相关者访谈或质量属性研讨会来捕获。商业目标可以以结构化的形式表达，并作为场景表示。效用树有助于以结构化形式捕获这些需求，并优先排序这些场景。</p><h2 id="Chapter-17-Designing-an-Architecture"><a href="#Chapter-17-Designing-an-Architecture" class="headerlink" title="Chapter 17: Designing an Architecture"></a>Chapter 17: Designing an Architecture</h2><p><strong>设计策略</strong>：</p><ul><li><strong>分解</strong>：架构决定质量属性，设计从整个系统开始，然后将其分解为部分。</li><li><strong>设计以满足架构上显著的需求（ASRs）</strong>：ASRs是设计必须满足的需求，数量较少但非常重要。</li><li><strong>生成和测试</strong>：将当前设计视为假设，测试是否满足需求，如果不满足则生成新的假设。</li></ul><p><strong>其他质量需求</strong>：</p><ul><li>如果设计不满足特定的非ASR质量需求，则需要调整设计、削弱需求、改变优先级或声明需求无法与ASR一起满足。</li></ul><p><strong>生成和测试</strong>：</p><ul><li><strong>初始假设的来源</strong>：理想来源是现有系统和框架，不太理想的来源是模式和策略、领域分解、设计检查表。</li><li><strong>如何测试假设</strong>：使用已覆盖的分析技术，输出是当前设计未满足的需求列表。</li><li><strong>如何生成下一个假设</strong>：添加缺失的责任，使用策略调整假设的质量属性行为。</li><li><strong>何时完成</strong>：当所有ASR都满足或设计活动预算耗尽时。</li></ul><p><strong>属性驱动设计方法（ADD）</strong>：</p><p>将分解过程建立在软件必须满足的质量属性上</p><ul><li>ADD是许多已讨论技术的打包，是一个迭代方法。每次迭代选择系统的一部分进行设计，收集该部分的所有ASR，生成并测试该部分的设计。</li><li>ADD不产生完整设计，而是产生具有责任的容器集合、容器之间的交互和信息流</li></ul><p><strong>ADD的步骤</strong>：</p><ul><li><p>选择系统的一个元素进行设计。</p></li><li><p>确定所选元素的ASR。</p><blockquote><p>如果所选元素是整个系统，则使用 Utility Tree（如前所述）。 如果所选元素位于分解树的更下方，则根据该元素的要求生成utility tree 。</p></blockquote></li><li><p>为所选元素生成设计解决方案。</p></li><li><p>清点剩余需求并选择下一次迭代的输入。</p></li><li><p>重复步骤1-4，直到所有ASR都得到满足。</p></li></ul><p>如果已满足 quality 属性要求，则无需进一步考虑。 如果未满足 quality 属性要求，则 将其委托Delegate给其中一个子元素或者在子元素之间拆分它 ，如果 quality 属性不满足，看看能不能弱化。如果它不能得到满足或削弱，那么它就无法得到满足。</p><p>约束被视为已处理质量属性要求</p><ul><li>–Satisfied</li><li>–Delegated</li><li>–Split</li><li>–Unsatisfiable</li></ul><p><strong>总结</strong>：</p><ul><li>设计架构是确定ASR、对元素进行生成和测试以分解它以满足ASR，并迭代直到需求得到满足的过程。</li></ul><h2 id="Chapter-18-Documenting-Software-Architectures"><a href="#Chapter-18-Documenting-Software-Architectures" class="headerlink" title="Chapter 18: Documenting Software Architectures"></a>Chapter 18: Documenting Software Architectures</h2><p><strong>架构文档的用途和受众</strong>：</p><ul><li>架构文档必须足够透明和易于理解，以便新员工快速理解。</li><li>文档应具体到足以作为施工蓝图，并包含足够的信息以作为分析的基础。</li><li>架构文档既是规定性prescriptive的（规定应该是什么）又是描述性descriptive的（描述事实）。</li></ul><p><strong>架构文档的三种用途</strong>：</p><ul><li><strong>教育</strong>：向团队新成员、外部分析师或评估者、新架构师介绍系统。</li><li><strong>利益相关者之间沟通的主要工具</strong>：系统分析和构建的基础；架构告诉实施者要实现什么。</li><li><strong>架构评估的基础</strong>：文档作为评估架构的基础。</li></ul><p><strong>文档表示法</strong>：Notations</p><ul><li><strong>非正式表示法</strong>：使用通用绘图和编辑工具，语义用自然语言描述。</li><li><strong>半正式表示法</strong>：标准化表示法，规定图形元素和构造规则；缺乏对这些元素含义的完整语义处理；从这个意义上说，UML 是一种半正式的表示法。</li><li><strong>正式表示法</strong>：具有精确（通常基于数学的）语义的表示法，支持自动化工具；语法和语义的正式分析都是可能的。</li></ul><p><strong>视图（Views）</strong>：</p><ul><li>视图将软件架构分解为多个有趣且易于管理的系统表示。</li><li>文档化架构是文档化相关视图并添加适用于多个视图的文档的过程</li></ul><p><strong>模块视图和C&amp;C视图</strong>：</p><ul><li><p>模块视图：元素包括模块、关系包括“是部分”、“依赖于”、“是”。<strong>约束</strong>：不同的模块视图可能会施加特定的拓扑约束，例如对模块之间的可见性的限制。</p></li><li><p>C&amp;C视图：元素包括组件和连接器，关系包括连接<em>Attachments</em>（组件通过其端口与连接器的特定角色连接）和接口委托<em>Interface</em> <em>delegation</em>（组件端口与 “内部” 子体系结构中的一个或多个端口相关联。连接器的角色的情况类似）。</p><ul><li><p><strong>约束</strong>：</p><ul><li><p>组件只能连接连接件</p></li><li><p>–Attachments can only be made between compatible兼容的 ports and roles.</p><p>–Interface delegation can only be defined between two compatible ports (or two compatible roles).</p><p>–Connectors cannot appear in isolation; a connector must be attached to a component.</p></li></ul></li></ul></li></ul><p><strong>质量视图</strong>：</p><ul><li>质量视图可以针对特定利益相关者或解决特定问题进行定制tailored。</li><li>通过提取相关的结构视图并将它们打包在一起而形成的。</li></ul><p>Quality Views: Examples</p><ol><li><p><strong>安全视图（Security View）</strong>：</p><ul><li><strong>目的</strong>：展示具有某种安全角色或责任的组件，这些组件如何通信，任何安全信息的数据存储库，以及对安全感兴趣的存储库。</li><li><strong>内容</strong>：视图的上下文信息会显示系统环境中的其他安全措施（如物理安全）。</li><li><strong>行为部分</strong>：展示安全协议的操作以及人类如何与安全元素交互，捕获系统如何响应特定威胁和漏洞。</li></ul><p>2.<strong>通信视图（Communications View）</strong>：</p><ul><li><strong>目的</strong>：特别有助于全球分散和异构的系统。</li><li><strong>内容</strong>：展示所有组件到组件的通道、各种网络通道、服务质量参数值和并发区域。</li><li><strong>用途</strong>：用于分析某些类型的性能和可靠性（如死锁或竞态条件检测）。</li><li><strong>行为部分</strong>：可能展示网络带宽如何动态分配。</li></ul><p>3.<strong>异常或错误处理视图（Exception or Error-Handling View）</strong>：</p><ul><li><strong>目的</strong>：帮助阐明和关注错误报告和解决机制。</li><li><strong>内容</strong>：展示组件如何检测、报告和解决故障或错误。</li><li><strong>用途</strong>：帮助识别错误源和每个错误的适当纠正措施。</li></ul><p>4.<strong>可靠性视图（Reliability View）</strong>：</p><ul><li><strong>目的</strong>：建模如复制和切换等机制。</li><li><strong>内容</strong>：描绘时序问题和事务完整性。</li></ul><p>5.<strong>性能视图（Performance View）</strong>：</p><ul><li><strong>目的</strong>：展示架构的那些方面有助于推断系统的性能。</li><li><strong>内容</strong>：展示网络流量模型、操作的最大延迟等。</li></ul></li></ol><p><strong>选择视图的方法</strong>：</p><ul><li>构建利益相关者&#x2F;视图表，合并视图以减少数量，优先排序和分阶段</li></ul><p><strong>构建文档包</strong>：</p><ul><li>Documentation package 包括视图和超出视图的文档</li></ul><p><strong>文档化视图</strong>：</p><ul><li>包括主要展示<strong>Primary Presentation</strong>：主要展示显示视图的元素和关系</li><li>元素目录**（Element Catalog）**:元素目录详细说明至少在主要展示中描绘的那些元素,包括元素及其属性、关系及其属性、元素接口、元素行为</li><li>上下文图**（Context Diagram）**:上下文图显示系统或视图中系统部分与其环境的关系，环境中的实体可能是人类、其他计算机系统或物理对象，如传感器或受控设备</li><li>可变性指南<strong>Variability Guide</strong>：可变性指南显示如何行使架构中作为变体点的一部分的任何变体点。</li><li>理由<strong>Rationale</strong>：理由解释视图中反映的设计是如何形成的</li></ul><p><strong>超出视图的文档化信息</strong>：（~~~~）</p><ul><li>包括文档控制信息、文档路线图、视图文档化方式、系统概述、视图间映射、理由和目录</li></ul><p><strong>文档化行为</strong>：</p><ul><li>行为文档通过描述视图中的架构元素如何相互作用来补充每个视图</li><li>行为文档支持对 系统死锁的可能性 系统在所需时间内完成任务的能力 最大内存消耗 以及更多的推理。</li></ul><p><strong>文档化质量属性</strong>：~~~~</p><ul><li>质量属性在文档中有五种主要表现方式，包括理由、架构元素的服务、质量属性的语言、需求映射和利益相关者的路线图。</li></ul><p><strong>文档化快速变化的架构</strong>：</p><ul><li>对于运行时变化或高频率发布和部署周期的架构，文档化所有版本的系统的真实情况，并记录架构允许的变化。</li></ul><p><strong>在敏捷开发项目中文档化架构</strong>：</p><ul><li>采用模板或标准组织来捕获设计决策，仅在视图有明确的利益相关者时才计划文档化视图。</li></ul><p><strong>总结</strong>：</p><ul><li>必须理解写作的用途和受众。架构文档作为各种利益相关者之间沟通的手段。</li></ul><h2 id="Chapter-19-Architecture-Implementation-and-Testing？？"><a href="#Chapter-19-Architecture-Implementation-and-Testing？？" class="headerlink" title="Chapter 19: Architecture, Implementation, and Testing？？"></a>Chapter 19: Architecture, Implementation, and Testing？？</h2><p><strong>架构与实现</strong>：</p><ul><li><p>保持代码与架构一致</p><p>：使用四种技术来保持代码和架构的一致性，避免“架构侵蚀”：</p><ul><li>将设计嵌入代码中。</li><li>使用框架。</li><li>使用代码模板。</li><li>保持代码和架构的一致性。</li></ul></li></ul><p><strong>将设计嵌入代码</strong>：</p><ul><li>架构作为实现的蓝图，实施者知道他们正在实现的架构结构，并可以在代码中作为注释进行文档化。</li></ul><p><strong>框架</strong>：</p><ul><li>框架是一组围绕特定主题组织的可重用类。程序员使用框架提供的服务。</li></ul><p><strong>防止架构侵蚀</strong>：</p><ul><li>使用工具强制执行架构约束，标记过时的文档，并安排文档&#x2F;代码同步时间。</li></ul><p><strong>架构与测试</strong>：</p><ul><li><strong>单元测试</strong>：架构定义了要测试的单元及其职责和交互。测试框架将驱动被测试的元素。</li><li><strong>集成测试</strong>：集成测试可以测试功能、性能、可用性和安全性。</li><li><strong>网络效应</strong>：错误可能导致性能下降，配置错误可能导致网络效应。网络效应最好通过自监控系统发现。</li></ul><p><strong>总结</strong>：</p><ul><li>实现活动可以将架构知识嵌入代码中，模板可用于重复出现的关键部分，通过使用工具和管理流程可以防止架构侵蚀。</li><li>单元和集成测试依赖于架构知识和测试框架。网络效应在将系统部署到数千台服务器时难以发现。架构师应参与多种测试活动。</li></ul><h2 id="Chapter-20-Architecture-Reconstruction-and-Conformance？？"><a href="#Chapter-20-Architecture-Reconstruction-and-Conformance？？" class="headerlink" title="Chapter 20: Architecture Reconstruction and Conformance？？"></a>Chapter 20: Architecture Reconstruction and Conformance？？</h2><p>架构重构和一致性</p><ol><li><p><strong>架构重建的原因</strong>：</p><ul><li>当你负责一个已存在的系统但不知道其架构时，可能需要进行架构重建。这可能是因为原始架构从未被记录、文档丢失或文档与系统不同步。</li></ul></li><li><p><strong>重建的目的</strong>：</p><ul><li>文档化不存在或过时的架构。</li><li>确保建成的架构与设计的架构一致。</li></ul></li><li><p><strong>重建映射</strong>：</p><ul><li>在系统最初开发时，其架构元素被映射到特定的实现元素。在重建这些架构元素时，需要应用原始映射的逆向。</li></ul></li><li><p><strong>重建工具</strong>：</p><ul><li>架构重建是一个工具密集型活动，工具通过扫描源代码来提取系统信息。工具还可能分析其他工件，如构建脚本或运行系统的跟踪。</li></ul></li><li><p><strong>重建工作台</strong>：</p><ul><li>架构重建工作台应该是开放的，易于集成新工具，并提供一个集成框架，使得添加的新工具不会不必要地影响现有工具或数据。</li></ul></li><li><p><strong>重建阶段</strong>：</p><ul><li><strong>原始（Raw information） 视图提取</strong>：从各种源（主要是源代码、执行跟踪和构建脚本）获取架构的原始信息。</li><li><strong>数据库构建</strong>：将原始提取的信息转换为标准形式，用于填充重建数据库。</li><li><strong>视图融合和操作（<em>fusion and manipulation</em>）</strong>：结合数据库中存储的信息的各种视图。（单个视图可能不包含完整或完全准确的信息。视图融合可以提高整体准确性。）</li><li><strong>架构分析</strong>：视图融合将产生关于架构的一组假设，这些假设需要经过测试以验证其正确性。</li></ul></li><li><p><strong>静态与动态信息</strong>：</p><ul><li>静态信息通过观察系统工件the system artifacts获得，动态信息通过观察系统运行获得。目标是融合两者以创建更准确的系统视图。</li></ul></li><li><p><strong>视图提取的常用工具</strong>：~~~~</p><p>静态：</p><ul><li>包括解析器(Parsers)、抽象语法树（AST）分析器、词法分析器(Lexical analyzers)</li></ul><p>动态：</p><ul><li>分析器（Profilers）、代码插桩工具（Code instrumen-tation tools）等。</li></ul><table><thead><tr><th align="left"><strong>Tool</strong></th><th><strong>Description</strong></th><th></th></tr></thead><tbody><tr><td align="left">Parsers</td><td>解析器分析代码并从中生成内部表示（用于生成机器代码）。可以保存此内部表示以获取视图。</td><td></td></tr><tr><td align="left">Abstract Syntax Tree (AST) analyzers</td><td>AST 分析器执行与解析器类似的工作，但它们构建了解析信息的显式树表示。我们可以构建遍历 AST 的分析工具，并以适当的格式输出选定的架构相关信息。</td><td></td></tr><tr><td align="left">Lexical analyzers</td><td>词法分析器将源项目纯粹作为词法元素或标记的字符串进行检查。词法分析器的用户可以指定要匹配和输出的一组代码模式。类似地，一组临时工具（如 grep 和 Perl）可以在代码中执行模式匹配和搜索，以输出一些所需的信息。所有这些工具（代码生成解析器、基于 AST 的分析器、词法分析器和临时模式匹配器）都用于输出静态信息。</td><td></td></tr><tr><td align="left">Profilers</td><td>分析和代码覆盖率分析工具可用于在执行代码时输出有关代码的信息，并且通常不涉及向系统添加新代码。</td><td></td></tr><tr><td align="left">Code instrumen-tation  tools</td><td>代码插桩在测试领域具有广泛的适用性，涉及向系统添加代码以在系统执行时输出特定信息。在面向方面的编程语言中，方面可以用于相同的目的，并且具有将插桩代码与被监视的代码分开的优势。</td><td></td></tr></tbody></table></li><li><p><strong>数据库构建</strong>：</p><ul><li>原始视图可能过于具体，无法帮助理解架构。需要操作这些视图以折叠信息并显示抽象。</li></ul></li><li><p><strong>视图融合</strong>View Fusion：</p><ul><li><p>提取的视图被操作以创建融合视图，融合视图结合了一个或多个提取视图的信息。</p></li><li><p>扩展</p></li><li><blockquote><ol><li><strong>静态视图（Static Views）</strong>：<blockquote><ul><li>从源代码中提取的视图，显示系统的静态结构，如类、接口、方法和它们之间的关系。</li></ul><ol start="2"><li><p><strong>动态视图（Dynamic Views）</strong>：</p><ul><li><p>通过观察系统运行时的行为获得的视图，显示系统的动态交互，如方法调用、消息传递和运行时依赖关系。</p></li><li><blockquote><ol><li><strong>执行跟踪视图（Execution Trace Views）</strong>：<blockquote><pre><code class="hljs"> &gt;    - 显示系统运行时的详细执行跟踪，包括函数调用、返回和异常处理。</code></pre></blockquote></li></ol></blockquote></li></ul><blockquote><pre><code class="hljs"> &gt; 2. **方法调用视图（Method Call Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示对象或组件之间的方法调用序列，帮助理解系统的运行时交互。</code></pre><blockquote><pre><code class="hljs"> &gt; 3. **消息序列视图（Message Sequence Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统中组件或对象之间传递的消息序列，通常用于分析通信协议和数据流。</code></pre><blockquote><pre><code class="hljs"> &gt; 4. **性能分析视图（Performance Analysis Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统运行时的性能指标，如响应时间、吞吐量和资源利用率。</code></pre><blockquote><pre><code class="hljs"> &gt; 5. **资源使用视图（Resource Usage Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统运行时对资源（如CPU、内存、网络）的使用情况。</code></pre><blockquote><pre><code class="hljs"> &gt; 6. **并发和同步视图（Concurrency and Synchronization Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统中的并发线程、锁和同步机制，帮助分析并发问题。</code></pre><blockquote><pre><code class="hljs"> &gt; 7. **故障注入视图（Fault Injection Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统在注入故障时的行为，用于测试系统的容错能力和恢复机制。</code></pre><blockquote><pre><code class="hljs"> &gt; 8. **配置和部署视图（Configuration and Deployment Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统的配置和部署状态，包括组件的部署位置和配置参数。</code></pre><blockquote><pre><code class="hljs"> &gt; 9. **动态依赖视图（Dynamic Dependency Views）**：</code></pre></blockquote><pre><code class="hljs">         &gt;      &gt;    - 显示系统运行时的依赖关系，包括动态加载的库和模块。</code></pre><blockquote><pre><code class="hljs"> &gt; 10. **运行时拓扑视图（Runtime Topology Views）**：</code></pre></blockquote><pre><code class="hljs">          &gt;      &gt;     - 显示系统运行时的组件拓扑结构，包括组件之间的连接和通信路径。</code></pre></li></ol></blockquote></li></ol><ol start="3"><li><strong>依赖视图（Dependency Views）</strong>：<blockquote><ul><li>显示系统中组件或模块之间的依赖关系，帮助识别系统的模块化结构。</li></ul><ol start="4"><li><p><strong>层次视图（Layered Views）</strong>：</p><ul><li>显示系统的分层结构，通常用于表示不同抽象层次的组件及其交互。</li></ul></li><li><p><strong>组件和连接器视图（Component-and-Connector Views）</strong>：</p><ul><li>显示系统的主要处理单元和数据存储，以及它们之间的连接路径。</li></ul></li><li><p><strong>模块视图（Module Views）</strong>：</p><ul><li>显示系统的模块化结构，包括模块之间的“属于”和“依赖于”关系。</li></ul></li><li><p><strong>分配视图（Allocation Views）</strong>：</p><ul><li>显示软件元素与环境元素之间的映射关系，通常用于分析性能、可用性和安全性。</li></ul></li><li><p><strong>质量视图（Quality Views）</strong>：</p><ul><li>针对特定质量属性（如安全性、性能、可靠性）的视图，显示与这些属性相关的架构元素和关系。</li></ul></li></ol></blockquote></li></ol></blockquote></li></ul></li><li><p><strong>架构分析：查找违规Violations</strong>：</p><ul><li>视图融合给出了关于架构的一组假设，这些假设需要经过测试以验证其是否符合架构师的意图。</li></ul></li><li><p><strong>指导方针</strong>：</p><ul><li>在进行架构重建项目之前，要有目标和一组目标或问题。现有的系统文档可能无法准确反映系统的实现，因此可能需要忽略现有文档。</li></ul></li><li><p><strong>总结</strong>：</p><ul><li>架构重建和架构一致性是架构师工具箱中的重要工具，确保系统按设计方式构建，并以与其创建者的意图一致的方式发展。架构重建的结果可以用于多种方式，包括作为文档化架构的基础、恢复建成的架构或检查与“设计的”架构的一致性。</li></ul></li></ol><h2 id="Chapter-21-Architecture-Evaluation"><a href="#Chapter-21-Architecture-Evaluation" class="headerlink" title="Chapter 21: Architecture Evaluation"></a>Chapter 21: Architecture Evaluation</h2><p><strong>评估形式</strong>：</p><ul><li><p><strong>设计者评估</strong>：设计者在设计过程中对关键设计决策或完成设计里程碑进行评估。</p></li><li><p><strong>同行评审Peer Review</strong>：与代码同行评审类似，架构设计也可以进行同行评审。</p></li><li><p><strong>外部分析</strong>：由外部评估者对已设计的架构进行客观分析。</p></li><li><p><strong>设计者评估</strong>：</p><p>设计者应在每次做出关键设计决策时评估所选方案和竞争方案。</p><ul><li>评估的深度取决于决策的重要性、潜在替代方案的数量以及“足够好”与“完美”的权衡。</li></ul></li><li><p><strong>同行评审</strong>：</p><ul><li>架构设计可以在设计过程中的任何时刻进行同行评审。</li><li>同行评审步骤包括确定质量属性场景、架构师展示架构、评审者提问、记录潜在问题等。</li></ul></li><li><p><strong>外部分析</strong>：</p><ul><li>外部评估者可以提供客观的架构分析。</li><li>外部团队通常用于评估完整的架构。</li></ul></li></ul><p><strong>评估的上下文因素</strong>：</p><ul><li>可用的工件、结果的受众、评估的执行者、参与的利益相关者以及业务目标。</li></ul><p><strong>架构权衡分析方法The Architecture Tradeoff Analysis Method（ATAM）</strong>：</p><ul><li>ATAM用于评估软件架构，适用于各种领域。</li><li>ATAM设计使得评估者不需要熟悉架构或其业务目标，系统不必已经构建，且可能有大量利益相关者。</li></ul><p><strong>ATAM参与者</strong>：</p><ul><li>评估团队：正在评估其体系结构的项目外部。 三到五个人;一个人可以在 ATAM 中担任多个角色。 他们需要被认可为有能力、公正的局外人。</li><li>项目决策者：这些人有权为开发项目发声或有权授权对其进行更改。 他们通常包括项目经理，如果有可识别的客户为开发项目买单，他或她也可能在场（或代表）。 建筑师始终被包括在内 – 建筑师必须自愿参与。</li><li>架构利益相关者：对架构的宣传具有既得利益。 利益相关者包括开发人员、测试人员、集成者、维护者、性能工程师、用户、与所考虑的系统交互的系统构建者，以及可能的其他人。 12 到 15 个</li></ul><p><strong>ATAM评估团队角色</strong>：</p><ul><li>团队领导:设置评估;与客户协调，确保满足客户的需求;建立评估合同;形成评估小组;看到最终报告已生成并交付（尽管编写可能被委派）</li><li>评估领导:运行评估；促进场景的引出；管理场景选择&#x2F;优先级排序过程；促进针对架构的场景评估；促进现场分析。</li><li>场景记录员Scenario scribe：在场景引出过程中在翻页板或白板上写场景；捕捉每个场景的商定措辞，暂停讨论直到确切措辞被捕获。</li><li>会议记录员Proceedings scribe:在笔记本电脑或工作站上以电子形式捕捉会议记录：原始场景、激励每个场景的问题（通常在场景措辞本身中丢失）以及将每个场景应用于架构时的解决方案；还生成已采纳场景的打印列表，供所有参与者分发。</li><li>提问者提出与质量属性相关的架构兴趣问题，通常与他或她有专业知识的质量属性相关。</li></ul><p><strong>ATAM输出</strong>：</p><ul><li>架构的简洁展示、业务目标的阐述、优先级质量属性需求、风险和非风险的集合、风险主题、架构决策与质量需求的映射、敏感性sensitivity 和权衡点tradeoff 的集合。</li></ul><p><strong>ATAM的无形输出</strong>Intangible Outputs：</p><ul><li>利益相关者的社区意识、架构师与利益相关者之间的开放沟通渠道、所有参与者对架构及其优缺点的更好理解。</li></ul><p><strong>ATAM阶段</strong>：</p><ul><li><p>合作与准备:</p><ul><li><strong>活动</strong>：物流Logistics、规划、利益相关者招募recruitment、团队组建formation。</li><li><strong>参与者</strong>：评估团队领导和关键项目决策者。</li><li><strong>典型持续时间</strong>：根据需要非正式进行，可能持续几周。</li></ul></li><li><p>评估步骤1-6</p><ul><li><strong>活动</strong>：步骤1-6。</li><li><strong>参与者</strong>：评估团队和项目决策者。</li><li><strong>典型持续时间</strong>：1-2天，随后是2-3周的间歇。</li></ul></li><li><p>评估步骤7-9</p><ul><li><strong>活动</strong>：步骤7-9。</li><li><strong>参与者</strong>：评估团队、项目决策者、利益相关者。</li><li><strong>典型持续时间</strong>：2天。</li></ul></li><li><p>后续报告生成和交付。</p><ul><li><strong>活动</strong>：报告生成和交付、流程改进。</li><li><strong>参与者</strong>：评估团队和评估客户。</li><li><strong>典型持续时间</strong>：1周。</li></ul></li></ul><p>step:</p><ol><li><strong>步骤 1：介绍 ATAM（Present the ATAM）</strong>：<ul><li>评估领导向项目代表(the assembled project representatives)介绍ATAM。</li><li>解释所有人将遵循的流程，回答问题，并为剩余活动设定背景和期望。</li></ul></li><li><strong>步骤 2：介绍业务驱动因素（Present Business Drivers）</strong>：<ul><li>项目决策者（理想情况下是项目经理或系统的客户）从业务角度介绍系统概述。</li><li>描述系统最重要的功能、相关技术、管理、经济或政治约束、业务目标和背景以及主要利益相关者。</li></ul></li><li><strong>步骤 3：介绍架构（Present the Architecture）</strong>：<ul><li>主架构师（或架构团队）描述架构。</li><li>架构师涵盖技术约束，并描述用于满足需求的架构方法（或模式、策略）。</li></ul></li><li><strong>步骤 4：识别架构方法（Identify Architectural Approaches）</strong>：<ul><li>ATAM侧重于通过理解其架构方法（尤其是模式和策略）来分析架构。</li><li>评估团队识别并记录模式和策略。</li></ul></li><li><strong>步骤 5：生成效用树（Generate Utility Tree）</strong>：<ul><li>通过<strong>质量属性效用树</strong>详细阐述质量属性目标。</li><li>效用树通过定义架构师努力提供的相关质量属性需求来使需求具体化。</li></ul></li><li><strong>步骤 6：分析架构方法（Analyze Architectural Approaches）</strong>：<ul><li>评估团队逐一检查最高排名的场景；架构师解释架构如何支持每个场景。</li><li>评估团队记录相关架构决策，并识别和记录风险、非风险、敏感点和权衡。</li></ul></li><li><strong>步骤 7：头脑风暴和优先排序场景（Brainstorm and Prioritize Scenarios）</strong>：<ul><li>利益相关者头脑风暴与其个人角色相关的操作性场景。</li><li>收集场景后，通过投票进行优先排序。</li></ul></li><li><strong>步骤 8：分析架构方法（Analyze Architectural Approaches）</strong>：<ul><li>评估团队使用最高排名的新生成场景执行与步骤6相同的活动。</li><li>架构师解释相关架构决策如何有助于实现每个场景。</li></ul></li><li><strong>步骤 9：呈现结果（Present Results）</strong>：<ul><li>评估团队私下会议，将风险归类为风险主题，基于某些共同的潜在问题或系统性缺陷systemic deficiency。</li><li>汇总评估信息并呈现给利益相关者，包括架构方法、场景及其优先级、效用树、发现的风险、记录的非风险、敏感点和权衡点。</li></ul></li></ol><p><strong>轻量级架构评估</strong>：</p><ul><li>基于ATAM的轻量级架构评估方法，适用于较小、风险较低的项目。</li><li>可能在一天或半天内完成，由组织内部成员执行。</li></ul><blockquote><table><thead><tr><th><strong>Step</strong></th><th><strong>Time</strong></th><th><strong>Notes</strong></th></tr></thead><tbody><tr><td>1.  Present the ATAM</td><td>0  hours</td><td>Participants  already familiar with process.</td></tr><tr><td>2.  Present business  drivers</td><td>0.25  hours</td><td>The participants are expected to  understand the system and its business goals and their priorities. A brief  review  ensures that  these are fresh in everyone’s mind and that there are no surprises.</td></tr><tr><td>3.  Present architecture</td><td>0.5  hours</td><td>All participants  are expected to be familiar with the system. A brief overview  of the architecture, using at least module and C&amp;C views, is presented. 1-2 scenarios are traced through  these views.</td></tr><tr><td>4.  Identify architectural approaches</td><td>0.25  hours</td><td>The architecture approaches for  specific quality attribute concerns are identified by the architect. This may  be done as a portion of step 3.</td></tr><tr><td>5.  Generate QA  utility tree</td><td>0.5-  1.5  hours</td><td>Scenarios  might exist: part of previous evaluations, part of design, part of  requirements elicitation. Put these in  a tree. Or, a utility tree may already  exist.</td></tr><tr><td>6.  Analyze architectural approaches</td><td>2-3  hours</td><td>This step—mapping the highly  ranked scenarios onto the architecture—consumes the bulk of the time and can  be expanded or contracted as needed.</td></tr><tr><td>7.  Brainstorm scenarios</td><td>0  hours</td><td>This step can be omitted as the  assembled (internal) stakeholders are expected to contribute scenarios  expressing their concerns in step 5.</td></tr><tr><td>8.  Analyze architectural approaches</td><td>0  hours</td><td>This step is also omitted, since  all analysis is done in step 6.</td></tr><tr><td>9. Present results</td><td>0.5  hours</td><td>At the end of an evaluation, the  team reviews the existing and newly discovered risks, nonrisks,  sensitivities, and tradeoffs and discusses whether any new risk themes have  arisen.</td></tr></tbody></table></blockquote><p><strong>总结</strong>：</p><ul><li>如果系统重要到需要显式设计其架构，那么该架构应该被评估。</li><li>评估的数量和每次评估的范围可能因项目而异。</li><li>设计者应在做出重要决策的过程中进行评估。</li><li>轻量级评估可以在项目中多次执行作为同行评审练习。</li><li>ATAM是一种全面的软件架构评估方法，通过让项目决策者和利益相关者明确列出质量属性需求（以场景形式）并阐明与执行每个高优先级场景相关的架构决策，从而理解决策的风险或非风险，以发现架构中的任何问题点。</li><li>基于ATAM的轻量级架构评估提供了一种廉价、低仪式的架构评估，可以在一个下午完成。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2025/03/30/TheFirstArticle/"/>
    <url>/2025/03/30/TheFirstArticle/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2025/03/30/TheFirstArticle/OIP.jpg"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>main线程为主线程，为程序的入口；在一个进程中，如果有多个线程，线程的调度由调度器安排，调度器与操作系统紧密相关，先后顺序无法人为干预</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>线程是交替执行（单核，并行），线程开启不一定立即执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>        System.out.println(<span class="hljs-string">&quot;main&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现runnable接口"><a href="#实现runnable接口" class="headerlink" title="实现runnable接口"></a>实现runnable接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;run\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>()).<span class="hljs-title function_">start</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;main\n&quot;</span>);;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>推荐是用Runnable接口，因为Java是单继承，同时runnable方便一个对象被多个线程使用</p></blockquote><h3 id="实现callable接口"><a href="#实现callable接口" class="headerlink" title="实现callable接口"></a>实现callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Boolean&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;call&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        <span class="hljs-comment">//创建服务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//提交执行</span><br>        Future&lt;Boolean&gt; submit = executorService.submit(myCallable);<br>        <span class="hljs-comment">//获取结果</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> submit.get();<br>        System.out.println(b);<br>        <span class="hljs-comment">//关闭服务</span><br>        executorService.shutdown();<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>callable存在返回值，重写call方法</p><h3 id="Thread与runnable的关系"><a href="#Thread与runnable的关系" class="headerlink" title="Thread与runnable的关系"></a>Thread与runnable的关系</h3><p><strong><code>Thread</code> 类</strong>： <code>Thread</code> 是 Java 提供的线程实现类，<strong>直接继承</strong> <code>Thread</code> <strong>并重写其</strong> <code>run()</code> <strong>方法</strong>即可创建线程。</p><p><strong><code>Runnable</code> 接口</strong>： <code>Runnable</code> 是一个函数式接口（仅包含 <code>run()</code> 方法），<strong>通过实现</strong> <code>Runnable</code> <strong>并传递给</strong> <code>Thread</code> <strong>对象</strong>来创建线程</p><h4 id="底层联系"><a href="#底层联系" class="headerlink" title="底层联系"></a><strong>底层联系</strong></h4><ul><li><strong><code>Thread</code> 类实现了 <code>Runnable</code> 接口</strong>： <code>Thread</code> 的 <code>run()</code> 方法源码如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>        target.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// target 是传入的 Runnable 对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>继承Thread：</p><p>优点：简单</p><p>缺点：单继承限制；资源共享困难，每个 <code>Thread</code> 子类实例是独立的线程对象，难以共享同一任务逻辑</p><p>实现Runnable接口：</p><p>优点：</p><ul><li><strong>解耦任务与线程</strong>：<code>Runnable</code> 仅定义任务逻辑，线程管理由 <code>Thread</code> 处理，符合单一职责原则。</li><li><strong>资源共享</strong>：多个线程可共享同一个 <code>Runnable</code> 实例（需注意线程安全）。</li><li><strong>避免单继承限制</strong>：可通过实现多个接口扩展功能。</li><li><strong>Lambda 简化</strong>（Java 8+）</li></ul><p>缺点：需要额外创建 <code>Thread</code> 对象来执行任务。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">StaticProxy</span> <span class="hljs-variable">staticProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticProxy</span>(person);<br>        staticProxy.marry();<br>    &#125;<br><br><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MarryEvent</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MarryEvent</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我要结婚了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MarryEvent</span> &#123;<br>    <span class="hljs-keyword">private</span> MarryEvent target; <span class="hljs-comment">// 改为接口类型</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StaticProxy</span><span class="hljs-params">(MarryEvent target)</span> &#123; <span class="hljs-comment">// 接收接口类型</span><br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">marry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理开始&quot;</span>);<br>        target.marry();<br>        System.out.println(<span class="hljs-string">&quot;代理结束&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解耦性</strong>：代理类不依赖具体实现类，可以代理<strong>任何实现了</strong> <strong><code>MarryEvent</code></strong> <strong>接口的对象</strong>。</li><li><strong>扩展性</strong>：未来新增实现类（如 <code>Company</code>、<code>Robot</code>）时，无需修改代理类代码。</li><li><strong>符合设计模式思想</strong>：代理模式的核心是通过抽象（接口）控制对真实对象的访问。</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理的**“动态”**本质体现在：</p><ol><li>运行时生成代理类</li><li>动态绑定目标对象</li><li>统一处理任意接口方法</li><li>自动适配接口变化</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxy</span>  &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-comment">// 创建真实对象</span><br>        <span class="hljs-title class_">UserService</span> realService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br><br>        <span class="hljs-comment">// 创建调用处理器</span><br>        <span class="hljs-title class_">InvocationHandler</span> handler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(realService);<br><br>        <span class="hljs-comment">// 动态生成代理对象</span><br>        <span class="hljs-title class_">UserService</span> proxy = (<span class="hljs-title class_">UserService</span>) <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">newProxyInstance</span>(<br>            <span class="hljs-title class_">UserService</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">getClassLoader</span>(),  <span class="hljs-comment">// 1. 类加载器 用于加载代理类的字节码，通常使用目标接口的类加载器</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;<span class="hljs-title class_">UserService</span>.<span class="hljs-property">class</span>&#125;,      <span class="hljs-comment">// 2. 代理接口数组 声明代理类要实现的接口，决定代理对象有哪些方法</span><br>            handler                              <span class="hljs-comment">// 3. 调用处理器 定义代理行为的实际处理逻辑</span><br>        );<br><br>        <span class="hljs-comment">// 通过代理对象调用方法</span><br>        proxy.<span class="hljs-title function_">addUser</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>        proxy.<span class="hljs-title function_">deleteUser</span>(<span class="hljs-number">1001</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//接口定义</span><br> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-title class_">String</span> name);<br>    <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteUser</span>(int id);<br>&#125;<br><span class="hljs-comment">//真实对象实现</span><br><span class="hljs-comment">//只处理业务本身，不管代理相关逻辑</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;添加用户: &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">int id</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;删除用户ID: &quot;</span> + id);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用处理器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Object</span> target; <span class="hljs-comment">// 真实对象 持有被代理对象的引用，可以是任意实现了接口的对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">LoggingHandler</span>(<span class="hljs-title class_">Object</span> target) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">target</span> = target;<br>    &#125;<br><br><span class="hljs-comment">//proxy 参数  动态生成的代理对象本身，一般不需要直接使用</span><br><span class="hljs-comment">//method 参数 当前被调用的方法对象，可通过getName()获取方法名</span><br><span class="hljs-comment">//args 参数   方法参数数组，可通过索引访问具体参数值</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">Object</span> proxy, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args) throws <span class="hljs-title class_">Throwable</span> &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;[日志] 方法调用: &quot;</span> + method.<span class="hljs-title function_">getName</span>());<br>        <span class="hljs-title class_">Object</span> result = method.<span class="hljs-title function_">invoke</span>(target, args); <span class="hljs-comment">//通过反射机制调用真实对象的方法</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;[日志] 方法执行完成&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>静态代理</strong>：编译前已存在<code>.java</code>代理类文件</li><li><strong>动态代理</strong>：运行时在内存中生成代理类字节码，无物理文件</li><li><strong>统一入口</strong>：所有方法调用都通过<code>invoke</code>方法路由</li><li><strong>无需硬编码</strong>：不依赖具体方法名，自动适配接口变化</li><li><strong>无需硬编码</strong>：不依赖具体方法名，自动适配接口变化</li><li>支持多个实现类的机制</li></ul><h4 id="多个实现类实例"><a href="#多个实现类实例" class="headerlink" title="多个实现类实例"></a>多个实现类实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyThread.Dynamic;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现类1：支付宝支付</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;支付宝支付: &quot;</span> + amount);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现类2：微信支付</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPayService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;微信支付: &quot;</span> + amount);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 动态代理客户端</span><br><br><br><span class="hljs-comment">// 统一日志处理器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoggingHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;【日志】&quot;</span> + target.getClass().getSimpleName() + <span class="hljs-string">&quot; 开始执行&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;【日志】执行完成&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建不同实现类的代理</span><br>        <span class="hljs-type">PaymentService</span> <span class="hljs-variable">proxy1</span> <span class="hljs-operator">=</span> createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AlipayService</span>());<br>        <span class="hljs-type">PaymentService</span> <span class="hljs-variable">proxy2</span> <span class="hljs-operator">=</span> createProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WechatPayService</span>());<br><br>        proxy1.pay(<span class="hljs-number">100.0</span>); <span class="hljs-comment">// 代理支付宝</span><br>        proxy2.pay(<span class="hljs-number">200.0</span>); <span class="hljs-comment">// 代理微信支付</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PaymentService <span class="hljs-title function_">createProxy</span><span class="hljs-params">(PaymentService target)</span> &#123;<br>        <span class="hljs-keyword">return</span> (PaymentService) Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;PaymentService.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(target)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态代理和静态代理"><a href="#动态代理和静态代理" class="headerlink" title="动态代理和静态代理"></a>动态代理和静态代理</h3><table><thead><tr><th>特性</th><th>静态代理</th><th>动态代理</th></tr></thead><tbody><tr><td>代理类生成方式</td><td>手动编码实现</td><td>运行时通过反射动态生成</td></tr><tr><td>适用场景</td><td>代理单一固定接口</td><td>代理多个不同接口</td></tr><tr><td>代码冗余</td><td>每个接口需单独编写代理类</td><td>一个处理器可代理所有接口方法</td></tr><tr><td>维护成本</td><td>接口变更时代理类需同步修改</td><td>接口变更不影响代理逻辑</td></tr></tbody></table><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>&#x2F;&#x2F;函数式接口：只能定义一个抽象方法</p><p>&#x2F;&#x2F;对于函数式接口，我们可以用Lambda表达式来创建该接口的对象</p><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>new–start(runnable)–run–block&#x2F;end</p><h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><p>通过设置标志位停止线程</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStop</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-built_in">boolean</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getName</span>()+<span class="hljs-string">&quot; &quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>)&#123;<br>        flag=<span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">TestStop</span> testStop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestStop</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testStop).<span class="hljs-title function_">start</span>();<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getName</span>()+<span class="hljs-string">&quot; &quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">90</span>)&#123;<br>                testStop.<span class="hljs-title function_">stop</span>();<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;----------stop----------&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h4><p>sleep：可以模拟网络延迟，倒计时；</p><p>每个对象都有一个锁，sleep不会释放锁</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSleep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> int ticketNums = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(ticketNums&lt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br><br><br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getName</span>()+<span class="hljs-string">&quot;-----拿到了第&quot;</span>+ticketNums--+<span class="hljs-string">&quot;票&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">TestSleep</span> testSleep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestSleep</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testSleep,<span class="hljs-string">&quot;小明&quot;</span>).<span class="hljs-title function_">start</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testSleep,<span class="hljs-string">&quot;老师&quot;</span>).<span class="hljs-title function_">start</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(testSleep,<span class="hljs-string">&quot;黄牛党&quot;</span>).<span class="hljs-title function_">start</span>();<br><br>        <span class="hljs-title class_">Date</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">System</span>.<span class="hljs-title function_">currentTimeMillis</span>());<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).<span class="hljs-title function_">format</span>(date));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><p>yield</p><h4 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h4><p>join</p><h3 id="守护线程（daemon）"><a href="#守护线程（daemon）" class="headerlink" title="守护线程（daemon）"></a>守护线程（daemon）</h3><p>线程分为用户线程和守护线程</p><p>虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕</p><p>守护线程的作用包括：后台记录日志，监控内存，垃圾回收等待</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">thread.<span class="hljs-built_in">setDaemon</span>()<br></code></pre></td></tr></table></figure><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>通过等待机制（排队）解决并发问题</p><p>形成条件：队列+锁 （每个对象都有一个锁，可以将锁交给当前队列中的线程）</p><p>锁机制synchronize存在的问题：</p><ul><li>一个线程拥有锁会导致其它等待的线程挂起</li><li>在多线程竞争下，加锁、释放锁会导致较多的上下文切换和调度延时，引起性能问题</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置（可以给线程设置优先级，但CPU可能有自己的想法），引起性能问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyThread.unsafe;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">unsafeBank</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Account&quot;</span>);<br><br>        <span class="hljs-type">Drawing</span> <span class="hljs-variable">boy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Drawing</span>(<span class="hljs-number">800</span>, <span class="hljs-string">&quot;boy&quot;</span>, account);<br>        <span class="hljs-type">Drawing</span> <span class="hljs-variable">girl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Drawing</span>(<span class="hljs-number">700</span>, <span class="hljs-string">&quot;girl&quot;</span>, account);<br><br>        boy.start();<br>        girl.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-type">int</span> money;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(<span class="hljs-type">int</span> money, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Account account;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> drawMoney;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> leftMoney;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Drawing</span><span class="hljs-params">(<span class="hljs-type">int</span> drawMoney, String name, Account account)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.drawMoney = drawMoney;<br><br>        <span class="hljs-built_in">this</span>.account = account;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (drawMoney &gt; account.money) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;want money&quot;</span>+drawMoney+<span class="hljs-string">&quot;but only have &quot;</span>+account.money);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        account.money -= drawMoney;<br>        leftMoney += drawMoney;<br>        System.out.println(account.name + <span class="hljs-string">&quot;余额为&quot;</span> + account.money);<br>        System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; own &quot;</span> + leftMoney);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://qc24bwv5u3.feishu.cn/sync/CYiFdqNy7smuMcb104ScxdKVnUg">https://qc24bwv5u3.feishu.cn/sync/CYiFdqNy7smuMcb104ScxdKVnUg</a></p><ol><li><strong>并发修改导致覆盖</strong>： 假设初始余额为 1000：<ol><li>线程 A（取 800）和线程 B（取 700）均通过检查。</li><li>线程 A 执行 <code>account.money -= 800</code>，余额变为 200。</li><li>线程 B <strong>在 A 修改前</strong>读取到余额仍为 1000，执行 <code>account.money -= 700</code>，结果变为 300，覆盖了线程 A 的修改。</li></ol></li></ol><p><a href="https://qc24bwv5u3.feishu.cn/sync/GIXedEaLasqVx6bHPjAcF9HKnab">https://qc24bwv5u3.feishu.cn/sync/GIXedEaLasqVx6bHPjAcF9HKnab</a></p><p>线程 A 和 <strong>线程 B</strong> 同时通过初始条件检查（<code>800 &lt;= 1000</code> 和 <code>700 &lt;= 1000</code>）。</p><p>线程 A先执行扣款：</p><ul><li>读取 <code>account.money = 1000</code>，计算 <code>1000 - 800 = 200</code>，写回后余额变为 <strong>200</strong>。</li></ul><p>线程 B开始执行扣款：</p><ul><li>读取到的 <code>account.money</code> 已经是线程 A 修改后的 <strong>200</strong>。</li><li>计算 <code>200 - 700 = -500</code>，写回后余额变为 <strong>-500</strong>。</li></ul><h4 id="解决synchronized"><a href="#解决synchronized" class="headerlink" title="解决synchronized"></a>解决synchronized</h4><p>通过synchronized给共享的资源加锁</p><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切 换所打断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (account)&#123;<br>        <span class="hljs-keyword">if</span> (drawMoney &gt; account.money) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;want money&quot;</span>+drawMoney+<span class="hljs-string">&quot;but only have &quot;</span>+account.money);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        account.money -= drawMoney;<br>        leftMoney += drawMoney;<br>        System.out.println(account.name + <span class="hljs-string">&quot;余额为&quot;</span> + account.money);<br>        System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; own &quot;</span> + leftMoney);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronize解读"><a href="#synchronize解读" class="headerlink" title="synchronize解读"></a>synchronize解读</h3><h4 id="Mark-Word的作用与结构"><a href="#Mark-Word的作用与结构" class="headerlink" title="Mark Word的作用与结构"></a><strong>Mark Word的作用与结构</strong></h4><p><strong>Mark Word</strong>是Java对象头（Object Header）的核心组成部分，用于存储对象的运行时元数据,支撑锁升级机制</p><p>。其结构根据对象锁状态的不同而变化，具体包含以下信息：</p><ul><li><strong>锁状态标志</strong>（2位）：标识当前锁状态（无锁、偏向锁、轻量级锁、重量级锁）</li><li><strong>线程ID</strong>（54位，偏向锁状态下）：记录持有偏向锁的线程ID</li><li><strong>GC分代年龄</strong>（4位）：记录对象在Survivor区的存活次数，超过阈值则晋升老年代</li><li><strong>哈希码</strong>（31位）：延迟计算的<code>identityHashCode</code>，加锁后可能被移动到Monitor中</li><li><strong>轻量级锁指针</strong>（62位）：指向线程栈中的锁记录（Lock Record）</li><li><strong>重量级锁指针</strong>（62位）：指向操作系统级别的Monitor对象（互斥量）</li></ul><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDJiZDYwNWVlYjgxMDQzNjQ5YTIxYzc2MmViMDk2N2NfbTYwR08zQ2pmU3E3NEpTUWlMUERkT3RDbmpURlRFMVJfVG9rZW46WHhtU2JnNkpkb0h3WTd4cjM3MGNPWUJEbkFMXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><p>锁升级是JVM动态优化同步性能的核心机制，流程如下：</p><ol><li><strong>无锁 → 偏向锁</strong>：单线程首次获取锁</li><li><strong>偏向锁 → 轻量级锁</strong>：检测到多线程竞争</li><li><strong>轻量级锁 → 重量级锁</strong>：自旋失败超过阈值（自适应自旋）</li></ol><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>偏向锁</strong>是JVM针对单线程重复访问同步资源的优化，旨在减少无竞争场景下的同步开销其核心思想是：<strong>若锁始终由同一线程获取，则跳过</strong><strong><a href="https://qc24bwv5u3.feishu.cn/wiki/BQMBwEyRQiWsnLkUiUYcZcbynnb">CAS操作</a>****，直接进入同步代码</strong>。</p><h5 id="偏向锁的运作机制："><a href="#偏向锁的运作机制：" class="headerlink" title="偏向锁的运作机制："></a><strong>偏向锁的运作机制：</strong></h5><ol><li><strong>初始状态</strong>： 对象刚创建时，Mark Word处于无锁状态（锁标志<code>01</code>，偏向锁标记<code>0</code>）</li><li><strong>首次获取偏向锁</strong>： 当线程首次访问同步代码时：<ol><li>通过<strong>CAS操作</strong>将Mark Word的偏向锁标记置为<code>1</code>，并记录线程ID和时间戳</li><li>后续该线程可直接进入同步代码，无需任何同步操作</li></ol></li><li><strong>偏向锁的撤销</strong>： 若其他线程尝试竞争锁：<ol><li>JVM暂停持有偏向锁的线程（类似GC停顿）</li><li>检查原线程是否存活：<ul><li><strong>存活且仍需锁</strong>：升级为轻量级锁，原线程继续执行。</li><li><strong>不存活或已释放</strong>：撤销偏向锁，恢复到无锁状态</li></ul></li></ol></li><li><strong>批量重偏向与撤销</strong>： JVM通过<code>epoch</code>字段优化多线程场景，允许在一定次数内批量重偏向锁，避免频繁撤销</li></ol><h5 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a><strong>适用场景：</strong></h5><ul><li><strong>单线程独占</strong>：如初始化操作、缓存加载等。</li><li><strong>低竞争环境</strong>：锁被多个线程交替访问但无并发冲突</li></ul><h5 id="偏向锁的优缺点"><a href="#偏向锁的优缺点" class="headerlink" title="偏向锁的优缺点"></a><strong>偏向锁的优缺点</strong></h5><ul><li><strong>优点</strong>：<ul><li><strong>零CAS开销</strong>：单线程场景下直接跳过同步操作</li><li><strong>减少锁竞争</strong>：通过线程ID匹配避免不必要的锁升级</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>撤销代价高</strong>：多线程竞争时需暂停线程并升级锁，影响性能</li><li><strong>默认禁用趋势</strong>：Java 15后默认关闭偏向锁，因现代应用多线程竞争更普遍</li></ul></li></ul><p>偏向锁的撤销</p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 （面试时使用）</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁通过<strong>CAS自旋</strong>避免线程阻塞。线程获取锁时，将对象头中的Mark Word复制到线程栈的锁记录（Lock Record），并通过CAS将对象头替换为指向该记录的指针。若成功则获取锁，失败则自旋重试；若自旋失败多次，锁膨胀为重量级锁</p><p><strong>适用场景</strong>：</p><ul><li>少量线程交替执行同步块（如短时间任务队列）</li><li>同步代码执行速度极快（如简单的计数器操作）</li></ul><p>（1）轻量级锁加锁</p><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间（Lock Record记录），并将对象头中的Mark Word（前30位 （25位的hashcode，4位的分代年龄，1位是否为偏向锁））复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针（指向线程栈帧里边的Lock Record的指针）。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p>（2）轻量级锁解锁</p><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word（Lock Record记录）替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖**操作系统互斥量（Mutex）**实现。线程竞争失败后直接阻塞，由操作系统调度唤醒。锁状态通过对象头指向Monitor对象（管程）管理，涉及用户态与内核态切换</p><p>ObjectMonitor是Java虚拟机（JVM）中实现重量级锁的核心数据结构，通过操作系统底层的监视器（Monitor）机制控制线程同步。它是synchronized关键字在竞争激烈场景下的底层实现基础</p><p>ObjectMonitor属性：</p><ol><li>header ： 重量级锁保存markword的地方</li><li>own: 指向当前持有锁的线程（类似“图书借阅记录”）；对象的markword里边也保存了指向monitor的指针；</li><li>_cxq 队列： 竞争队列。 A线程持有锁没有释放； B和C线程同时过来争抢锁，都被block了，此时会将B和C线程加入到 该队列。</li><li>EntryList队列：存放等待获取锁的阻塞线程队列（类似“图书馆排队队伍”），当锁释放时从此队列唤醒线程。同步队列。A线程释放锁，B和C线程中会选定一个继承者（可以去争抢锁的这个线程），另外一个线程会被放入我们的EntryList队列里边。</li><li>waitset：等待队列。Object wait的线程。存放调用wait()方法后进入等待状态的线程集合（类似“休息区等待通知的读者”），需通过notify()&#x2F;notifyAll()唤醒。</li></ol><p>工作流程</p><p>1、获取锁：</p><p>若_owner为null，当前线程直接获取锁并更新_owner。</p><p>若锁已被占用，线程进入_cxq自旋尝试获取，超时后加入_EntryList并阻塞。</p><p>2、释放锁：</p><p>清空_owner，唤醒_EntryList中的线程，或优先处理_cxq中的自旋线程。</p><p>3、<strong>wait&#x2F;notify机制</strong>：</p><p>调用wait()时，线程释放锁并进入_WaitSet；调用notify()时，从_WaitSet移出线程至_EntryList重新竞争锁。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>条件：互斥 保持 非抢占 循环</p><p>解决死锁</p><ol><li>破坏” 互斥” 条件：系统里取消互斥、若资源一般不被一个进程独占使用，那么死锁是肯定不会发生的，但一般 “互斥” 条件是无法破坏的，因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏 “互斥” 条件。</li><li>破坏 “请求和保持” 条件：</li></ol><ul><li>方法 1：所有的进程在开始运行之前，必须一次性的申请其在整个运行过程各种所需要的全部资源。<ul><li>优点：简单易实施且安全。</li><li>缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低了资源的利用率，造成资源浪费。</li></ul></li><li>方法 2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到，已经使用完毕的资源，然后再去请求新的资源。这样的话资源的利用率会得到提高，也会减少进程的饥饿问题。</li></ul><ol><li>破坏 “不剥夺” 条件：当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂的释放或者说被抢占了。</li><li>破坏 “循环等待” 条件：可以通过定义资源类型的线性顺序来预防，可以将每个资源编号，当一个进程占有编号为 i 的资源时，那么它下一次申请资源只能申请编号大于 i 的资源。</li></ol><p>避免死锁的几个常见方法。</p><ul><li>·避免一个线程同时获取多个锁。</li><li>·避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li><li>·尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li><li>·对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU2ODdkZDRkNDEzOWE0NmY3N2ZjYzZlYzA0ODk2NzZfd1RvY09jMGxTQzVNa0FvMTRSSFZTc0huQWFHYkpzS0JfVG9rZW46SEV2V2JDVVJVb1FNZTF4Vk1DeGNadm4ybll3XzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                lock.lock();<br>                <span class="hljs-keyword">if</span> (count&gt;<span class="hljs-number">0</span>)&#123;<br>                 System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;-----&quot;</span>+count--);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ReentrantLock实现了Lock接口</p><p>对比</p><table><thead><tr><th>特性</th><th>synchronized（作用于方法或代码块）</th><th>Lock比较灵活</th></tr></thead><tbody><tr><td>锁的获取与释放</td><td>隐式(自动获取与释放)</td><td>显式（需手动管理）</td></tr><tr><td>可中断性</td><td>不支持</td><td>支持 –&gt; lock.lockInterruptibly();</td></tr><tr><td>公平性</td><td>不支持(多个线程竞争锁时，可能产生“线程饥饿”（某些线程长期获取不到锁）)</td><td>支持(可以通过构造函数指定公平锁（new ReentrantLock(true)）)</td></tr><tr><td>条件变量</td><td>单一等待队列</td><td>多个条件队列（Condition）</td></tr><tr><td>性能</td><td>优化后接近 Lock</td><td>高并发下更优</td></tr><tr><td>功能扩展</td><td>简单</td><td>丰富（读写锁、超时锁等）</td></tr><tr><td>适用场景</td><td>简单同步需求</td><td>复杂同步逻辑或高并发场景</td></tr></tbody></table><p>Lock的条件变量</p><p>&#x2F;&#x2F; Lock 的 Condition 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (条件不满足) &#123;<br>        condition.await(); <span class="hljs-comment">// 等待条件</span><br>    &#125;<br>    <span class="hljs-comment">// 处理逻辑</span><br>    condition.signal();    <span class="hljs-comment">// 唤醒一个等待线程</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个<strong>int成员变量表示同步状态</strong>，通过<strong>内置的FIFO队列</strong>来完成资源获取线程的<strong>排队工作</strong>，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p><p>子类推荐被定义为自定义同步组件的<strong>静态内部类</strong>，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p><p>自定义LOCK</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-comment">// AQS 呢？如何使用呢？</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">//加锁的时候用 state int 类型</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>                <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(Thread.currentThread());<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//解锁的</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// 不用，当前线程释放锁，说明，当前线程持有锁。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//创建condition. wait notify</span><br>        Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-comment">//锁定的话，state == 1</span><br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//        sync.tryAcquire(); //调用错误</span><br>        sync.acquire(<span class="hljs-number">1</span>); <span class="hljs-comment">//传说中的模板方法吗？ 是的</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sync.isLocked();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedThreads</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sync.hasQueuedThreads();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AQS队列</p><p>同步器依赖内部的<strong>同步队列</strong>（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</p><p>节点是构成同步队列（等待队列，在Condition中将会介绍）的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部，同步队列的基本结构如图所示。</p><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=NGEwNGJmZDQ5OTUyZDY2MDVlY2NhMGY4ZDc1NjRiN2NfWTJ0V2hndVFQVGttSkVqTGFCSXBWUEZtWXk4MHhOZHVfVG9rZW46TEJNaGIyb1FsbzI0WFB4MUZER2M0NDUzblpmXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><p>通过CAS设置尾节点</p><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=YjFlNzY1MDlkY2Y3MzgyZTc0MWU2NDZjNjI2Y2Q1NWJfTm9KZU9EbUc5SmV5WDJORmY2V3dveEZSUkZ4Z3c2SGpfVG9rZW46T1k1cGIxZHJab2lHMFh4VjFYeGNwQndmblJnXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><h3 id="ReentrantLock（可重入）"><a href="#ReentrantLock（可重入）" class="headerlink" title="ReentrantLock（可重入）"></a>ReentrantLock（可重入）</h3><p>相对于 synchronized 它具备如下特点</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>getHoldCount()：当前线程调用 lock() 方法的次数。</li><li>getQueueLength()：当前正在等待获取 Lock 锁的线程的估计数。</li><li>​    getWaitQueueLength(Condition condition)：当前正在等待状态的线程的估计数，需要传入 Condition 对象。</li><li>​    hasWaiters(Condition condition)：查询是否有线程正在等待与 Lock 锁有关的 Condition 条件。</li><li>hasQueuedThread(Thread thread)：查询指定的线程是否正在等待获取 Lock 锁。</li><li>​    hasQueuedThreads()：查询是否有线程正在等待获取此锁定。</li><li>​    isFair()：判断当前 Lock 锁是不是公平锁。</li><li>​    isHeldByCurrentThread()：查询当前线程是否保持此锁定。</li><li>​    isLocked()：查询此锁定是否由任意线程保持。</li><li>​    tryLock()：线程尝试获取锁，如果获取成功，则返回 true，如果获取失败（即锁已被其他线程获取），则返回 false。</li><li>​    tryLock(long timeout，TimeUnit unit)：线程如果在指定等待时间内获得了锁，就返回true，否则返回 false。</li><li>​    lockInterruptibly()：如果当前线程未被中断，则获取该锁定，如果已经被中断则出现异常</li></ul><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p><p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><h4 id="利用reentrant解决哲学家就餐"><a href="#利用reentrant解决哲学家就餐" class="headerlink" title="利用reentrant解决哲学家就餐"></a>利用reentrant解决哲学家就餐</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ReentrantLock</span> &#123;<br>    <span class="hljs-title class_">String</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-title class_">String</span> name) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Thread</span> &#123;<br>    <span class="hljs-title class_">Chopstick</span> left;<br>    <span class="hljs-title class_">Chopstick</span> right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-title class_">Chopstick</span> left, <span class="hljs-title class_">Chopstick</span> right) &#123;  <span class="hljs-variable language_">super</span>(name);  <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = left;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = right;  &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 尝试获得左手筷子  </span><br>            <span class="hljs-keyword">if</span> (left.<span class="hljs-title function_">tryLock</span>()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 尝试获得右手筷子  </span><br>                    <span class="hljs-keyword">if</span> (right.<span class="hljs-title function_">tryLock</span>()) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;  <span class="hljs-title function_">eat</span>();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            right.<span class="hljs-title function_">unlock</span>();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    left.<span class="hljs-title function_">unlock</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;eating...&quot;</span>);  <span class="hljs-title class_">Sleeper</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitbreakfastQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigrette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasBreakfast</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitCigaretteQueue.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitbreakfastQueue.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br>    sleep(<span class="hljs-number">1</span>);<br>    sendBreakfast();<br>    sleep(<span class="hljs-number">1</span>);<br>    sendCigarette();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendCigarette</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>        hasCigrette = <span class="hljs-literal">true</span>;<br>        waitCigaretteQueue.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBreakfast</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>        hasBreakfast = <span class="hljs-literal">true</span>;<br>        waitbreakfastQueue.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h3><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY5MGY1YjZkZTkwODY4MThhY2NkYTI0OGI2MDcxOTdfWGtrRElqdmJQUTFjZndzVkw0Mk53YVBGR28zNU00TzZfVG9rZW46U3ppb2J6dDZab2xnTFF4cFhKUmNyOVY0bnFiXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><p>await、signal</p><h4 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h4><p>LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 暂停当前线程 </span><br>LockSupport.park(); <br> <span class="hljs-comment">// 恢复某个线程的运行</span><br>  LockSupport.unpark(暂停线程对象) <br></code></pre></td></tr></table></figure><ul><li><strong><code>LockSupport.park()</code></strong> 用于<strong>暂停当前线程</strong>的执行。若线程关联的许可（<code>permit</code>）可用（值为1），则立即返回并消耗该许可；若不可用（值为0），则线程会被阻塞，直到以下条件之一触发</li><li>其他线程调用 <code>unpark(该线程)</code>，使其许可变为1。</li><li>线程被中断（<code>interrupt()</code>）。</li><li>发生虚假唤醒（罕见情况）。</li><li><strong><code>LockSupport.unpark(Thread thread)</code></strong> 用于<strong>恢复指定线程</strong>的执行。若目标线程未被 <code>park()</code> 阻塞，则赋予其许可（值为1），后续调用 <code>park()</code> 时会立即返回；若目标线程已被阻塞，则直接唤醒它</li></ul><table><thead><tr><th>维度</th><th><strong>park()&#x2F;unpark()</strong></th><th><strong>wait()&#x2F;notify()</strong></th></tr></thead><tbody><tr><td>锁依赖</td><td>无需配合 synchronized 或锁对象</td><td>必须与 synchronized 块配合使用</td></tr><tr><td>唤醒粒度</td><td>精确唤醒指定线程</td><td>notify() 随机唤醒，notifyAll() 唤醒所有</td></tr><tr><td>中断响应</td><td>被中断后返回，但不会抛出 InterruptedException1</td><td>被中断后抛出 InterruptedException</td></tr><tr><td>死锁风险</td><td>无（因许可机制）</td><td>可能因锁竞争或顺序不当导致死锁</td></tr></tbody></table><h4 id="Volitate-synchronize-lock"><a href="#Volitate-synchronize-lock" class="headerlink" title="Volitate synchronize lock"></a>Volitate synchronize lock</h4><h4 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join"></a>Thread.join</h4><p>隐式唤醒、等待其它线程执行完成，其它线程会发送唤醒信号</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>interrupt</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>提前创建好多个线程，放入线程池中，可以重复利用</p><h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><p>线程池的真正实现类是 <strong>ThreadPoolExecutor，构造函数参数如下：</strong></p><ul><li><strong>corePoolSize</strong>（int 必需）：核心线程数。初始化时便创建，可以认为是最小线程数，不必频繁地创建和销毁线程。默认情况下，核心线程会一直存活，但是当将 <strong>allowCoreThreadTimeout</strong> 设置为 true 时，核心线程也会超时回收。</li><li><strong>maximumPoolSize</strong>（int 必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。</li><li><strong>keepAliveTime</strong>（long 必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。</li><li><strong>unit</strong>（TimeUnit 必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。</li><li>workQueue（BlockingQueue<Runnable>  必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。</Runnable></li><li>threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。</li><li>handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。</li></ul><p>使用流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(CORE_POOL_SIZE,<br>                                             MAXIMUM_POOL_SIZE,<br>                                             KEEP_ALIVE,<br>                                             TimeUnit.SECONDS,<br>                                             sPoolWorkQueue,<br>                                             sThreadFactory);<br><span class="hljs-comment">// 向线程池提交任务</span><br>threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        ... <span class="hljs-comment">// 线程执行的任务</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 关闭线程池</span><br>threadPool.shutdown(); <span class="hljs-comment">// 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</span><br>threadPool.shutdownNow(); <span class="hljs-comment">// 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</span><br></code></pre></td></tr></table></figure><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjU2YzQ2NWY0NWFjZmVlZDYxM2U1MDI1MTQ5Y2IyOGVfQ1hKaEFBOXVZOWZ0SWFzMkZLbU1iaG9NWG9KYUtjd1RfVG9rZW46SlM2TGI2QWxkb0RncXd4c2tPSmNnTlIybkZoXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：</p><h4 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h4><p>需要实现 <strong>ThreadFactory</strong> 接口，并实现 <strong>newThread(Runnable r)</strong> 方法。该参数可以不用指定，Executors 框架已经为我们实现了一个默认的线程工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default thread factory.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">poolNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br> <br>    DefaultThreadFactory() &#123;<br>        <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>        group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>                              Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                      poolNumber.getAndIncrement() +<br>                     <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r,<br>                              namePrefix + threadNumber.getAndIncrement(),<br>                              <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (t.isDaemon())<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>            t.setPriority(Thread.NORM_PRIORITY);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拒绝策略（handler）"><a href="#拒绝策略（handler）" class="headerlink" title="拒绝策略（handler）"></a>拒绝策略（handler）</h4><p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p><ul><li>AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。</li><li>CallerRunsPolicy：由调用线程处理该任务。</li><li>DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li><li>DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li><li>当然，也可以根据应用场景需要来实现<strong>RejectedExecutionHandler</strong>接口<strong>自定义策略</strong>。（最推荐）</li></ul><h4 id="线程池的监控与关闭"><a href="#线程池的监控与关闭" class="headerlink" title="线程池的监控与关闭"></a>线程池的监控与关闭</h4><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li>·taskCount：线程池需要执行的任务数量。</li><li>·completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>·largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>·getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li><li>·getActiveCount：获取活动的线程数。</li></ul><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</p><p><strong>关闭线程池：</strong></p><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>EXECUTOR框架</p><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=N2NjNzIzMWEwN2Y5YWIxYzkyNGZmYjM4YWM4MThhNDlfVTh3Mk9JZWlwYVp4eWEzVkxMSjhIS2Q3bGdMOXV6aVRfVG9rZW46TVJOeGJrSFJVbzVsU1N4NkJtcGNwYjhObkRoXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><p>框架的使用</p><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIyMzE3NGRkN2M0ZTYzYjk1ODNlMjdiNDUxM2E0NGVfRUxhek5BUHR2Nmh6eERaQ0xEYVB3TDVUbU9KNjJmMU1fVG9rZW46V21PaGJsUzhNbzMwam14cHBwOWNueTdpbmFjXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><h4 id="功能线程池"><a href="#功能线程池" class="headerlink" title="功能线程池"></a>功能线程池</h4><p>Executors已经为我们封装好了 4 种常见的功能线程池（可以利用exectuor创建的ThreadPoolExecutor类型），如下：</p><ul><li>定长线程池（FixedThreadPool）</li><li>定时线程池（ScheduledThreadPool ）</li><li>可缓存线程池（CachedThreadPool）</li><li>单线程化线程池（SingleThreadExecutor）</li></ul><h5 id="定长线程池（FixedThreadPool）"><a href="#定长线程池（FixedThreadPool）" class="headerlink" title="定长线程池（FixedThreadPool）"></a>定长线程池（FixedThreadPool）</h5><ul><li><strong>特点</strong>：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>：控制线程最大并发数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>fixedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h5 id="定时线程池（ScheduledThreadPool-）"><a href="#定时线程池（ScheduledThreadPool-）" class="headerlink" title="定时线程池（ScheduledThreadPool ）"></a>定时线程池（ScheduledThreadPool ）</h5><ul><li><strong>特点</strong>：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。</li><li><strong>应用场景</strong>：执行定时或周期性的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5</span><br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledThreadPool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>scheduledThreadPool.schedule(task, <span class="hljs-number">1</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 延迟1s后执行任务</span><br>scheduledThreadPool.scheduleAtFixedRate(task,<span class="hljs-number">10</span>,<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS);<span class="hljs-comment">// 延迟10ms后、每隔1000ms执行任务</span><br></code></pre></td></tr></table></figure><h5 id="可缓存线程池（CachedThreadPool）"><a href="#可缓存线程池（CachedThreadPool）" class="headerlink" title="可缓存线程池（CachedThreadPool）"></a>可缓存线程池（CachedThreadPool）</h5><p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是<strong>无界的</strong>。这里把keepAliveTime设置为60L，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。</p><ul><li><strong>特点</strong>：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。</li><li><strong>应用场景</strong>：执行大量、耗时少的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建可缓存线程池对象</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cachedThreadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>cachedThreadPool.execute(task);<br></code></pre></td></tr></table></figure><h5 id="单线程化线程池（SingleThreadExecutor）"><a href="#单线程化线程池（SingleThreadExecutor）" class="headerlink" title="单线程化线程池（SingleThreadExecutor）"></a>单线程化线程池（SingleThreadExecutor）</h5><p>SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1。其他参数与FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。</p><ul><li><strong>特点</strong>：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li><li><strong>应用场景</strong>：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建单线程化线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">singleThreadExecutor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 2. 创建好Runnable类线程对象 &amp; 需执行的任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     System.out.println(<span class="hljs-string">&quot;执行任务啦&quot;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 3. 向线程池提交任务</span><br>singleThreadExecutor.execute(task);<br></code></pre></td></tr></table></figure><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIxNzhjNTY4NjM4YTI1OGZhNzk1YzQ2MDU1ZDQ4NzlfWHhsNUNiN2V5dHJId0pSRmZCYWxWNEZoZUdRSDZKVmRfVG9rZW46QVNiamJscGE4b2MzVmN4YnI3SmNZYVNYbnZlXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><p>Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><ul><li><strong>RUNNING</strong>：运行状态，线程池可以接收新任务并处理已添加的任务。</li><li><strong>SHUTDOWN</strong>：关闭状态，线程池不再接收新任务，但会处理已提交的任务。</li><li><strong>STOP</strong>：停止状态，线程池不再接收新任务，也不处理已提交的任务。</li><li><strong>TIDYING</strong>：整理状态，所有任务已完成，线程池正在清理资源。</li><li><strong><a href="https://segmentfault.com/a/1190000041593817">TERMINATED：销毁状态，线程池已完全终止，所有资源已被释放。</a></strong></li></ul><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmY5NmFlOTliN2JhNTVmOTNlZTljMzAzNmFmZTk5M2RfRHN2VTlTbUN3b1VBcDNmMmhOaVkycVNFV0VvT1VjanpfVG9rZW46WVE0NmJzN1B5b0pNSzR4U3RXVmM3SEtBbkNiXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><h3 id="扩展–阻塞队列"><a href="#扩展–阻塞队列" class="headerlink" title="扩展–阻塞队列"></a>扩展–阻塞队列</h3><ul><li>阻塞队列（<code>BlockingQueue</code>）是一个<strong>支持两个附加操作</strong>的队列，这两个附加的操作<strong>支持阻塞的插入和移除方法</strong>。</li></ul><ol><li>支持阻塞的插入方法：当<strong>队列满</strong>时，队列会阻塞插入元素的线程，<strong>直到队列不满</strong>。</li><li>支持阻塞的移除方法：当<strong>队列为空</strong>时，获取元素的线程会<strong>等待队列变为非空</strong>。</li></ol><p><img src="https://qc24bwv5u3.feishu.cn/space/api/box/stream/download/asynccode/?code=N2VmYTNjMzk3MWQ1MTI2MDFlYTk3OGI3NTZhOGQ5M2NfdHBQNUhQOUNxZXVwWVJpQVNVTU80aDZuajRIbjJQaDdfVG9rZW46V1l3eGJQekhzbzZyTW54enhnemNiYjJFbmNjXzE3NDMzMjI5NTQ6MTc0MzMyNjU1NF9WNA" alt="img"></p><h4 id="Java中的七种阻塞队列"><a href="#Java中的七种阻塞队列" class="headerlink" title="Java中的七种阻塞队列"></a>Java中的七种阻塞队列</h4><ul><li><p>ArrayBlockingQueue：一个由<strong>数组</strong>结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。</p><ul><li><p>此队列按照<strong>先进先出（FIFO）</strong> 的原则对元素进行排序。构造方法如下：一把锁管理全部</p><ul><li><pre><code class="language-java"></code></pre></li></ul><p>public ArrayBlockingQueue(int capacity) {}<br>public ArrayBlockingQueue(int capacity, boolean fair) {}<br>public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) {}</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">    -</span> 参数<span class="hljs-code">`fair`</span>用于设置<span class="hljs-strong">**线程是否公平访问队列**</span>，默认值为<span class="hljs-code">`false`</span>，即指非公平地访问队列<br><br><span class="hljs-bullet">        -</span> 所谓公平访问是指阻塞的线程可以<span class="hljs-strong">**按照阻塞的先后顺序访问队列**</span>，即<span class="hljs-strong">**先阻塞线程先访问队列**</span>。<br><span class="hljs-bullet">        -</span> 非公平是<span class="hljs-strong">**对先等待的线程是非公平的**</span>。当队列<span class="hljs-strong">**可用**</span>时，<span class="hljs-strong">**阻塞的线程都可以争夺访问队列的资格**</span>，<span class="hljs-strong">**有可能先阻塞的线程最后才访问队列**</span>。<br><span class="hljs-bullet">        -</span> 为了保证公平性，通常会<span class="hljs-strong">**降低吞吐量**</span>。因此，参数<span class="hljs-code">`fair`</span>的默认值为<span class="hljs-code">`false`</span>。<br><br><span class="hljs-bullet">-</span> LinkedBlockingQueue： 一个由<span class="hljs-strong">**链表**</span>结构组成的有界阻塞队列，在未指明容量时，容量默认为 Integer.MAX<span class="hljs-emphasis">_VALUE。存在两把锁（take，put）</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">    - 此队列按照<span class="hljs-strong">**先进先出（FIFO）**</span> 的原则对元素进行排序</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">    - 此队列的默认和最大容量为`Integer.MAX_</span>VALUE<span class="hljs-code">`，**实际上被看做是无界阻塞队列**。`</span>LinkedBlockingQueue`的构造方法如下<br><br><span class="hljs-bullet">    -</span> <span class="hljs-code">```java</span><br><span class="hljs-code">    public LinkedBlockingQueue() &#123;&#125;</span><br><span class="hljs-code">    public LinkedBlockingQueue(int capacity) &#123;&#125;</span><br><span class="hljs-code">    public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) &#123;&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>PriorityBlockingQueue： 一个<strong>支持优先级</strong>排序的无界阻塞队列，对元素没有要求，<strong>可以实现 Comparable 接口 也可以提供 Comparator</strong> 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</p><ul><li><pre><code class="language-java"></code></pre></li></ul><p>  public PriorityBlockingQueue() {}<br>  public PriorityBlockingQueue(int initialCapacity){}<br>  public PriorityBlockingQueue(Collection&lt;? extends E&gt; c) {}<br>  public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) {<br>  <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>    - 使用无参构造函数创建时，默认初始化大小`DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">11</span>`。<br><br>    - 好奇？明明是一个无界阻塞队列，为何可以指定大小？原来使用**size 记录中的元素个数**，当`size &gt;= queue.length`时，会使用`tryGrow()方法`进行扩容。<br><br>- DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。<br><br>    - `DelayQueue` 是一个**支持延时获取元素**的**无界阻塞队列**，队列使用 `PriorityQueue` 来实现。<br><br>    - ```java<br>    public class DelayQueueTest &#123;<br>        public static void main(String[] args) throws InterruptedException &#123;<br>            DelayQueue&lt;Message&gt; delayQueue = <span class="hljs-keyword">new</span> DelayQueue()<span class="hljs-comment">;</span><br>            Message m1 = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">&quot;First Job&quot;</span>,<span class="hljs-number">5</span>, TimeUnit.SECONDS)<span class="hljs-comment">;</span><br>            Message m2 = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">&quot;Sec Job&quot;</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS)<span class="hljs-comment">;</span><br>            delayQueue.add(m2)<span class="hljs-comment">;</span><br>            delayQueue.add(m1)<span class="hljs-comment">;</span><br>    <br>            int length = delayQueue.size()<span class="hljs-comment">;</span><br>            for(int i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; length; i++) &#123;</span><br>                Message msg = delayQueue.take()<span class="hljs-comment">;</span><br>                System.out.println(msg)<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(String name, <span class="hljs-type">long</span> time, TimeUnit timeUnit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + timeUnit.toMillis(time);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> time - System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>        <span class="hljs-comment">//谁先到期谁先执行，通过 time 进行一个比较优先级</span><br>        <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> (Message) o;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeDiff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.time - msg.time;<br>        <span class="hljs-keyword">if</span>(timeDiff &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; - &quot;</span> + time;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>SynchronousQueue</strong>： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产（put）了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。<ul><li>SynchronousQueue<strong>是一个不存储元素的阻塞队列</strong>。每一个put操作必须等待一个take操作，否则不能继续添加元素。</li><li>使用场景，适合短期的小并发场景，且数据处理相当快速。</li><li>硬要说点好处：首先他们有缓冲容量，那么他可以避免在服务器宕机的情况下，从queue的角度来说，没有数据丢失这么一说。 他类似于一个<strong>传球手</strong>，中间没有任何介质阻碍。如果单纯的进行数据的传递且生产的线程与消费的线程生产时间和消费时间都比较匹配的话，他的性能能够很高。</li></ul></li><li>LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。<ul><li>双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。</li><li>与单项队列相比，如果竞争压力不大，而且也没必要从双端进行数据处理的场景下，用双向队列就适得其反了</li></ul></li><li>LinkedTransferQueue：是一个由<strong>链表结构</strong>组成的<strong>无界阻塞****TransferQueue</strong>队列。相对于其他阻塞队列，LinkedTransferQueue多了<strong>tryTransfer和transfer方法。</strong> 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。</li></ul><p><a href="https://blog.csdn.net/u014454538/article/details/97389421">Java高并发之阻塞队列（什么是阻塞队列、4对操作、7种阻塞队列、实现原理）</a></p><h4 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h4><p>Fork&#x2F;Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务(compute方法)，最终汇总每个小任务结果后得到大任务结果的框架。</p><ul><li><strong>双端队列与任务窃取</strong>： Fork&#x2F;Join框架中的每个工作线程维护一个双端队列（Deque）。当父任务调用子任务的<code>fork()</code>时，子任务会被推入当前线程的队列头部；而调用<code>join()</code>时，若子任务未完成，线程会优先从<strong>队列头部取出子任务执行</strong>（即“后进先出”策略），加速子任务处理</li><li><strong>避免线程阻塞</strong>： 如果子任务被其他线程窃取执行，当前线程在调用<code>join()</code>时，会通过循环尝试帮助完成子任务（或窃取其他任务），从而保持CPU利用率</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jdk;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.concurrent.Future;<br><span class="hljs-keyword">import</span> java.util.concurrent.RecursiveTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123; <span class="hljs-comment">//需要返回结果</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// 最多几个数字做子任务啊？</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> start; <span class="hljs-comment">//从那块相加。举例：从1 开始加</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<span class="hljs-comment">// 加到几？ 加到 4</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinTest</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//拆分任务，获取结果</span><br>        System.out.println(<span class="hljs-string">&quot;======================&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果任务足够小就计算任务</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">canCompute</span> <span class="hljs-operator">=</span> (end - start) &lt;= THRESHOLD;<br>        <span class="hljs-keyword">if</span> (canCompute) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>                sum += i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果任务大于阈值，就分裂成两个子任务计算</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">ForkJoinTest</span> <span class="hljs-variable">leftTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinTest</span>(start, middle);<br>            <span class="hljs-type">ForkJoinTest</span> <span class="hljs-variable">rightTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinTest</span>(middle + <span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">// 执行子任务</span><br>            leftTask.fork();<br>            rightTask.fork();<br>            <span class="hljs-comment">// 等待子任务执行完，并得到其结果</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> leftTask.join();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> rightTask.join();<br>            <span class="hljs-comment">// 合并子任务</span><br>            sum = leftResult + rightResult;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        <span class="hljs-comment">// 生成一个计算任务，负责计算1+2+3+4</span><br>        <span class="hljs-type">ForkJoinTest</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinTest</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// 执行一个任务</span><br>        Future&lt;Integer&gt; result = forkJoinPool.submit(task);<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(result.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><blockquote><p>它们的每个方法是原子的</p><p>但注意它们多个方法的组合不是原子的，见后面分析</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客持续开发中</title>
    <link href="/2025/03/30/hello-world/"/>
    <url>/2025/03/30/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="不要假装努力，结果不会陪你演戏"><a href="#不要假装努力，结果不会陪你演戏" class="headerlink" title="不要假装努力，结果不会陪你演戏"></a><strong>不要假装努力，结果不会陪你演戏</strong></h1><p><img src="/2025/03/30/hello-world/6478b3b7a3b29efd830788cc.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
